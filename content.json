{"meta":{"title":"WX'sMajula","subtitle":null,"description":null,"author":"王潇","url":"https://0922wx.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-08-28T12:30:36.000Z","updated":"2024-10-07T14:17:58.374Z","comments":true,"path":"about/index.html","permalink":"https://0922wx.github.io/about/index.html","excerpt":"","text":"王潇。 Majula这个名字出自黑暗之魂2，意为被遗忘遗弃之地。 就是这样。"},{"title":"分类","date":"2024-08-28T10:57:19.000Z","updated":"2024-08-28T11:30:11.761Z","comments":true,"path":"categories/index.html","permalink":"https://0922wx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"FirstofArray","slug":"FirstofArray","date":"2024-10-11T14:30:02.000Z","updated":"2024-10-11T14:34:40.827Z","comments":true,"path":"2024/10/11/FirstofArray/","permalink":"https://0922wx.github.io/2024/10/11/FirstofArray/","excerpt":"","text":"实现一个First&lt;T&gt;泛型，它接受一个数组T并返回它的第一个元素的类型。 1234type arr1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]type arr2 = [3, 2, 1]type head1 = First&lt;arr1&gt; // 应推导出 &#x27;a&#x27;type head2 = First&lt;arr2&gt; // 应推导出 3 12345678910111213141516171819// ============= Test Cases =============import type &#123; Equal, Expect &#125; from &#x27;./test-utils&#x27;type cases = [ Expect&lt;Equal&lt;First&lt;[3, 2, 1]&gt;, 3&gt;&gt;, Expect&lt;Equal&lt;First&lt;[() =&gt; 123, &#123; a: string &#125;]&gt;, () =&gt; 123&gt;&gt;, Expect&lt;Equal&lt;First&lt;[]&gt;, never&gt;&gt;, Expect&lt;Equal&lt;First&lt;[undefined]&gt;, undefined&gt;&gt;,]type errors = [ // @ts-expect-error First&lt;&#x27;notArray&#x27;&gt;, // @ts-expect-error First&lt;&#123; 0: &#x27;arrayLike&#x27; &#125;&gt;,]// ============= Your Code Here =============type First&lt;T extends any[]&gt; = what can i say? 毫无头绪捏 type First&lt;T extends any[]&gt; = T extends [infer F, ...any[]] ? F : never; 通过条件类型提取数组的第一个元素 F。[infer F, ...any[]] 表示一个数组，F 是第一个元素，...any[] 表示剩余的元素可以是任意类型。 我怎么感觉好像没看过这种东西 什么遍历 infer，完全找不到地方看","categories":[{"name":"TS类型体操","slug":"TS类型体操","permalink":"https://0922wx.github.io/categories/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"},{"name":"简单题","slug":"TS类型体操/简单题","permalink":"https://0922wx.github.io/categories/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/%E7%AE%80%E5%8D%95%E9%A2%98/"}],"tags":[]},{"title":"Object.key,value和entries","slug":"Object-key-value和entries","date":"2024-10-11T12:57:37.000Z","updated":"2024-10-11T13:08:28.530Z","comments":true,"path":"2024/10/11/Object-key-value和entries/","permalink":"https://0922wx.github.io/2024/10/11/Object-key-value%E5%92%8Centries/","excerpt":"","text":"key和value，键值对罢了 123console.log(Object.keys(&#123;name:&quot;tom&quot;,age:11&#125;); // [&quot;name&quot;,&quot;age&quot;]console.log(Object.values(&#123;name:&quot;tom&quot;,age:11&#125;) // [&#x27;tom&#x27;,11] 主要是记录一下entries() 1console.log(Object.entries(&#123;name:&quot;tom&quot;,age:11&#125;)//[Array(2),Arrar(2)] 我去，二维数组 1console.log(Object.entries([1,2,3])//[Array(2),Arrar(2),Arrar(2)] 手工返回键值对组成的数组，第一个元素是属性的键（始终是字符串），第二个元素是属性值。 那么绝配map了 123const obj = &#123; foo: &quot;bar&quot;, baz: 42 &#125;;const map = new Map(Object.entries(obj));console.log(map); // 输出: Map(2) &#123;&quot;foo&quot; =&gt; &quot;bar&quot;, &quot;baz&quot; =&gt; 42&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"}],"tags":[]},{"title":"神秘小厂","slug":"神秘小厂","date":"2024-10-10T11:51:17.000Z","updated":"2024-10-10T12:01:25.695Z","comments":true,"path":"2024/10/10/神秘小厂/","permalink":"https://0922wx.github.io/2024/10/10/%E7%A5%9E%E7%A7%98%E5%B0%8F%E5%8E%82/","excerpt":"","text":"面面相觑 1.vue的生命周期(没用过vue) 2.小程序做过吗(没有) 3.css2和css3有什么区别 4.怎么水平居中 5.es6新增了什么 6.==和===的区别 7.react怎么父传子 8.聊天室用了什么技术聊天(websocket) 反问: 主要用vue，原生小程序开发","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"ThreeJs一些概念","slug":"ThreeJs","date":"2024-10-09T10:40:57.000Z","updated":"2024-10-09T11:19:55.950Z","comments":true,"path":"2024/10/09/ThreeJs/","permalink":"https://0922wx.github.io/2024/10/09/ThreeJs/","excerpt":"","text":"三要素 场景 Scene 容器 相机 Camera 观察 渲染器 Render 组合 起步 随便找一个文件夹.yarn init,然后在设置里面写: 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot; &#125;, 然后yarn add -D vite yarn add -D three OK 始于此 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;module&quot;&gt; import * as THREE from &quot;three&quot; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建场景-&gt;创建相机-&gt;创建渲染器 12345678910&lt;script type=&quot;module&quot;&gt; import * as THREE from &quot;three&quot;; const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera( 45,window.innerWidth/window.innerHeight, 0.1, 1000 ) const renderer = new THREE.WebGLRenderer();&lt;/script&gt; 东西都有了，那要怎么才能看到呢？ document.body.appendChild(renderer.domElement); 获取camera元素","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"ThreeJs","slug":"前端/ThreeJs","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/ThreeJs/"},{"name":"事前准备","slug":"前端/ThreeJs/事前准备","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/ThreeJs/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"}],"tags":[]},{"title":"自留按钮动画","slug":"自留按钮动画","date":"2024-10-09T07:58:15.000Z","updated":"2024-10-09T08:17:52.202Z","comments":true,"path":"2024/10/09/自留按钮动画/","permalink":"https://0922wx.github.io/2024/10/09/%E8%87%AA%E7%95%99%E6%8C%89%E9%92%AE%E5%8A%A8%E7%94%BB/","excerpt":"","text":"十字形劈开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849.btn &#123; margin: 80px; width: 400px; height: 80px; position: relative; font-size: 4rem; background-color: #f2f2f2; color: black; z-index: 1; transition: 1s;&#125;.btn::before &#123; content: &quot;&quot;; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #262626; transform: rotateX(90deg); transition: 1s; z-index: -1;&#125;.btn:hover::before &#123; transform: rotateX(0deg);&#125;.btn::after &#123; content: &quot;&quot;; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #262626; transform: rotateY(90deg); transition: 1s; z-index: -1;&#125;.btn:hover::after &#123; transform: rotateY(0deg);&#125;.btn:hover &#123; color: #fff;&#125; 十字形黑到白,原理是通过旋转x和y轴得到 自上而下倒塌 12345678910111213141516171819202122232425.roate &#123; margin: 5px; width: 400px; height: 50px; margin-top: 200px; position: relative; overflow: hidden; background-color: inherit;&#125;.roate::before &#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; background-color: yellowgreen; z-index: -1; width: 100%; height: 100%; transform-origin: bottom left; transform: rotate(-90deg); transition: transform 1s ease-in-out;&#125;.roate:hover::before &#123; transform: rotate(0deg);&#125; 原理是before里画一团颜色，用transform旋转让他塌下来 填充 123456789101112131415161718192021222324252627282930313233.btn2 &#123; margin: 5px; width: 400px; height: 50px; margin-top: 200px; position: relative; background-color: inherit; overflow: hidden; color: burlywood; transition: all 1.5s; font-size: 1rem;&#125;.btn2::before &#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; background-color: burlywood; width: 100%; height: 100%; z-index: -1; transform-origin: left; transform: translateX(-100%); transition: transform 1s ease-in-out;&#125;.btn2:hover::before &#123; transform: translateX(0);&#125;.btn2:hover &#123; color: white;&#125; 悬浮放大 12345678910111213141516171819.btn &#123; padding: 10px; position: relative; background-color: inherit; text-transform: uppercase; color: black; transition: all 1.5s; font-size: 1.25rem; border: 3px solid black; font-weight: 300; letter-spacing: 2px;&#125;.btn:hover&#123; font-weight: 900; letter-spacing: 5px; border: 5px solid black;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/css/"}],"tags":[]},{"title":"计数排序","slug":"计数排序","date":"2024-10-08T12:01:06.000Z","updated":"2024-10-08T12:01:55.187Z","comments":true,"path":"2024/10/08/计数排序/","permalink":"https://0922wx.github.io/2024/10/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"第一眼 12345678910function countingSort(arr: number[]): number[] &#123; // Write your code here let len:number = arr.length const newArr:number[] = new Array(len).fill(0) for(let i =0;i&lt;len;i++)&#123; if(arr[i])&#123; &#125; &#125;&#125; 然后尬住了 拿到arr长度len 开辟长度为len的数组，并填充0 const newArr:number[] = new Array(len).fill(0) 第二眼 要求按arr最大值来定义数组长度，比如[1,1,3,2,1]的范围是[0…3],所以开辟res =[0,0,0,0] 所以得拿到最大值? 1const max = arr.find(...) find只能返回符合条件的第一个元素，不能找最大值 解构找到最大值 1const max = Math.max(...arr) reduce找到最大值 123const max =arr.reduce((acc,item) =&gt;&#123; return Math.max(acc,item)&#125;,arr[0]) acc当前最大值,item遍历元素 当然，acc是reduce原本就是接收的4个参数之一,还有个可选的initialValue Accumulator acc(累加器) Current Value cur(当前值) Current index idx(当前索引) Source Array src(源数组) 遍历arr 如果出现值，在特定位置计数加1 arr[i] newArr[i] ++ 第三眼 123456789function countingSort(arr: number[]): number[] &#123; // Write your code here let len:number = arr.length const max = Math.max(...arr) const newArr = Array(max).fill(0) for(let i=0;i&lt;len;i++)&#123; &#125;&#125; 相同数值再出现,再相同位置+1 有错 并非 const newArr = Array(max).fill(0) 而是 const newArr = Array(max + 1).fill(0) 为什么？ 因为要创建[0,max]全闭数组 第四眼 到底怎么计算元素出现次数? 123for(let num of arr)&#123; newArr[num]++&#125; 通过遍历输入数组 arr 中的每个数字 num，我们给 countArr[num] 这个位置的值加 1。 例如，如果输入数组是[2, 3, 2, 1]，则newArr将变为[0, 1, 2, 1] countArr[1] = 1 （数字 1 出现 1 次） countArr[2] = 2 （数字 2 出现 2 次） countArr[3] = 1 （数字 3 出现 1 次） 寄了 第五眼 看看洋人怎么写的 12345678 const frequencyArray = (new Array(100)).fill(0); const length = arr.length; for (let i = 0; i &lt; length; i++) &#123; frequencyArray[arr[i]] += 1; &#125; return frequencyArray;&#125; frequencyArray[arr[i]] += 1;疑似有点天才了","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"前言","slug":"前言","date":"2024-10-07T14:55:01.000Z","updated":"2024-10-07T15:16:17.697Z","comments":true,"path":"2024/10/07/前言/","permalink":"https://0922wx.github.io/2024/10/07/%E5%89%8D%E8%A8%80/","excerpt":"","text":"好好的力扣题不做，跑去刷洋人的题？","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"}],"tags":[]},{"title":"10-7","slug":"10-7","date":"2024-10-07T14:20:19.000Z","updated":"2024-10-07T14:23:25.077Z","comments":true,"path":"2024/10/07/10-7/","permalink":"https://0922wx.github.io/2024/10/07/10-7/","excerpt":"","text":"234234 这个简爱 鲜奶米布丁 豪赤!🤓👍","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"Diagonal Difference对角线差","slug":"Diagonal-Difference","date":"2024-10-07T12:38:13.000Z","updated":"2024-10-07T12:56:06.214Z","comments":true,"path":"2024/10/07/Diagonal-Difference/","permalink":"https://0922wx.github.io/2024/10/07/Diagonal-Difference/","excerpt":"","text":"Diagonal Difference | HackerRank 计算矩阵的对角线差 力扣有道求对角线和 1572. 矩阵对角线元素的和 - 力扣（LeetCode） 只要你知道两边的对角线怎么求，一切都会好起来的 左边的对角线就arr[i][i],右边的的是arr[i][length-1-i] HackerRank让你求的是左右对角线的差的绝对值 1234567891011function diagonalDifference(arr: number[][]): number &#123; // Write your code here const length = arr.length let primarySum = 0; let secondarySum = 0 for (let i = 0; i &lt; length; i++) &#123; primarySum += arr[i][i]; secondarySum += arr[i][length - 1 - i]; &#125; return Math.abs(primarySum - secondarySum);&#125; 遍历途中记录就行了 力扣的是求和，还需要关心到元素项是不是偶数，(说起来求差不用关心吗)： 123456789var diagonalSum = function(mat) &#123; const length = mat.length const mid = Math.floor(length / 2) let sum = 0 for (let i = 0; i &lt; length; i++) &#123; sum += mat[i][i] + mat[i][length - 1 - i] &#125; return sum - mat[mid][mid] * (length &amp; 1)&#125;; return sum - mat[mid][mid] * (length &amp; 1) 检查是否是奇数，如果是奇数，即中间元素被计算了两次，所以要减一次中心元素值 为什么会重复计算？ 因为奇数项的话，会有一个中心值 1 2 3 4 5 6 7 8 9 第一轮 1+3 sum=4 5+5 sum=4+10 =14 这里算了两次 9+7 sum=14+16 = 30 length &amp; 1 &amp;与 两个位都为1时，结果才为1 如果length是偶数，那他二进制最后一位就是0，相反就是1 那为什么求差就不用考虑奇偶呢 因为是求差，相同的早变成0了，没有的东西就不用考虑了","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"Flipping bits","slug":"Flipping-bits","date":"2024-10-07T12:35:16.000Z","updated":"2024-10-07T12:37:35.306Z","comments":true,"path":"2024/10/07/Flipping-bits/","permalink":"https://0922wx.github.io/2024/10/07/Flipping-bits/","excerpt":"","text":"Flipping bits | HackerRank 给你一个32-bits位无符号整数的列表，要求你输出你把它们中每个数二进制表示中的每位翻转之后的结果得到的新列表（即0变成1，1变成0）。 属于是知道js有左移右移就能秒了 右移（&gt;&gt;） - JavaScript | MDN (mozilla.org) 1234function flippingBits(n: number): number &#123; // Write your code here return ~n &gt;&gt;&gt; 0; &#125; 翻译：按位取反并无符号右移32位","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"Grading Students","slug":"Grading-Students","date":"2024-10-07T07:16:53.000Z","updated":"2024-10-07T12:34:31.508Z","comments":true,"path":"2024/10/07/Grading-Students/","permalink":"https://0922wx.github.io/2024/10/07/Grading-Students/","excerpt":"","text":"Grading Students | HackerRank 1234567891011121314function gradingStudents(grades: number[]): number[] &#123; // Write your code here return grades.map(grades =&gt; &#123; if (grades &lt; 38) &#123; return grades &#125; const currentGrades: number = grades const nextFive = Math.ceil(grades / 5) * 5 if (nextFive - currentGrades &lt;3)&#123; return nextFive &#125; return currentGrades &#125;)&#125; map方法遍历数组，为其每项执行回调函数，返回新数组","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"Breaking the Records","slug":"Breaking-the-Records","date":"2024-10-07T07:15:11.000Z","updated":"2024-10-07T07:16:16.101Z","comments":true,"path":"2024/10/07/Breaking-the-Records/","permalink":"https://0922wx.github.io/2024/10/07/Breaking-the-Records/","excerpt":"","text":"Breaking the Records | HackerRank 1234567891011121314151617function breakingRecords(scores: number[]): number[] &#123; // Write your code here let minRecord = scores[0] let maxRecord = scores[0] let minCount = 0 let maxCount = 0 for(let i =0;i&lt;scores.length;i++)&#123; if(scores[i] &gt; maxRecord)&#123; maxRecord = scores[i] maxCount ++ &#125; else if(scores[i] &lt; minRecord)&#123; minRecord = scores[i] minCount++ &#125; &#125; return [maxCount,minCount]&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"Time Conversion","slug":"Time-Conversion","date":"2024-10-07T07:07:42.000Z","updated":"2024-10-07T07:14:13.378Z","comments":true,"path":"2024/10/07/Time-Conversion/","permalink":"https://0922wx.github.io/2024/10/07/Time-Conversion/","excerpt":"","text":"Time Conversion | HackerRank 给定12小时AM/PM格式的时间，将其转换为军用（24 小时）时间。 123456789101112131415161718function timeConversion(s) &#123; // Write your code here let [hours,minutes,seconds] = s.split(&quot;:&quot;) const period = seconds.slice(-2) //AM or PM seconds = seconds.slice(0, 2); hours = parseInt(hours) if(period === &#x27;AM&#x27;)&#123; if(hours === 12)&#123; hours = 0 &#125; &#125; else &#123; if(hours !== 12)&#123; hours +=12 &#125; &#125; const militratHours = String(hours).padStart(2,&#x27;0&#x27;) return `$&#123;militratHours&#125;:$&#123;minutes&#125;:$&#123;seconds&#125;`&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"Mini-Max Sum","slug":"Mini-Max-Sum","date":"2024-10-07T07:07:09.000Z","updated":"2024-10-07T07:12:27.873Z","comments":true,"path":"2024/10/07/Mini-Max-Sum/","permalink":"https://0922wx.github.io/2024/10/07/Mini-Max-Sum/","excerpt":"","text":"Mini-Max Sum | HackerRank 给定 5 个正整数，求 5 个整数中 4 个整数相加的最小值和最大值。然后将各自的最小值和最大值打印为一行两个空格分隔的长整数。 123456789101112function miniMaxSum(arr) &#123; // Write your code here let Max = Math.max(...arr) let Min = Math.min(...arr) let sum = 0 for (let item of arr) &#123; sum += item &#125; let minimun = sum - Max let maximum = sum - Min console.log(minimun,maximum)&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"Lonely Integer","slug":"Lonely-Integer","date":"2024-10-07T05:56:25.000Z","updated":"2024-10-07T07:05:06.513Z","comments":true,"path":"2024/10/07/Lonely-Integer/","permalink":"https://0922wx.github.io/2024/10/07/Lonely-Integer/","excerpt":"","text":"Lonely Integer | HackerRank 给定一个整数数组，其中除一个元素外所有元素都出现两次，请找出唯一的元素。 用set做 123456789101112function lonelyinteger(a: number[]): number &#123; // Write your code here const numSet =new Set&lt;number&gt;() for(const num of a)&#123; if(numSet.has(num))&#123; numSet.delete(num) &#125; else &#123; numSet.add(num) &#125; &#125; return Array.from(numSet)[0]&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"Sparse Arrays 稀疏阵列","slug":"Sparse-Arrays","date":"2024-10-07T05:34:19.000Z","updated":"2024-10-07T07:05:23.533Z","comments":true,"path":"2024/10/07/Sparse-Arrays/","permalink":"https://0922wx.github.io/2024/10/07/Sparse-Arrays/","excerpt":"","text":"Sparse Arrays | HackerRank 有一个输入字符串集合和一个查询字符串集合。对于每个查询字符串，确定它在输入字符串列表中出现的次数。返回结果数组。 Example strings = [‘ab’,‘ab’,‘abc’] queries = [‘ab’,‘abc’,'bc] 对于query，在返回数组result= [2,1,0] 1234567891011121314function matchingStrings(strings: string[], queries: string[]): number[] &#123; // Write your code here let res:number[] = [] for(let query of queries)&#123; let count = 0 for (let item of strings)&#123; if(item === query)&#123; count++ &#125; &#125; res.push(count) &#125; return res&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"Divisible Sum Pairs 可除和对","slug":"数组","date":"2024-10-07T05:02:44.000Z","updated":"2024-10-07T07:05:43.302Z","comments":true,"path":"2024/10/07/数组/","permalink":"https://0922wx.github.io/2024/10/07/%E6%95%B0%E7%BB%84/","excerpt":"","text":"看不太懂,先留着 可除数和对 | HackerRank — Divisible Sum Pairs | HackerRank 给定一个整数数组和一个正整数k ，求(i,j) 对中i&lt;j和ar[i] +ar[j] 能被k整除的个数。 123456789101112function divisibleSumPairs(n: number, k: number, ar: number[]): number &#123; // Write your code here let count = 0 const remainderCount = new Array(k).fill(0) for(let i=0;i&lt;n;i++)&#123; const remainder = ar[i] % k const neededRemainder = (k -remainder) % k count += remainderCount[neededRemainder] remainderCount[remainder]++ &#125; return count&#125; count: 用于记录满足条件的数对的数量，初始值设为 0。 remainderCount: 用于存储余数的出现次数。长度为 k 的数组，初始时所有值为 0。其目的在于记录每个余数（0 到 k-1）的出现次数，方便后续查找。 const remainder = ar[i] % k; 计算当前元素 ar[i] 对 k 的余数，这样可以确定这个数在模 k 的情况下的分类。 const neededRemainder = (k - remainder) % k; 通过上面的公式，我们可以确定要与当前数ar[i]配对的另一个数的余数： 如果 remainder 是 0，neededRemainder 也是 0，这意味着另一个数也应该是 0（即 ar[j] 的余数为 0）。 如果 remainder 是 1 且 k 是 5，则 neededRemainder 是 4，这意味着要找的另一个数的余数应该是 4，以使得它们的和（即 1 + 4）能够被 5 整除。 更新 count: count += remainderCount[neededRemainder]：这一步的作用是，如果当前数的余数为 remainder，我们通过查找 remainderCount 数组来获取之前有多少个数的余数是 neededRemainder。这些数可以和当前数成对，从而构成符合条件的和。 更新 remainderCount: remainderCount[remainder]++：这行代码是将当前数的余数 remainder 的计数加 1，因为我们在处理完当前数后，希望将它也加入到余数的计数中，供后续的元素使用。","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"指定增删改链表思路","slug":"指定增删改链表思路","date":"2024-10-06T14:26:22.000Z","updated":"2024-10-06T14:36:55.548Z","comments":true,"path":"2024/10/06/指定增删改链表思路/","permalink":"https://0922wx.github.io/2024/10/06/%E6%8C%87%E5%AE%9A%E5%A2%9E%E5%88%A0%E6%94%B9%E9%93%BE%E8%A1%A8%E6%80%9D%E8%B7%AF/","excerpt":"","text":"连续做了HackerRank的链表题 怎么找到给定位置的节点前一项？(position以1开始计数，一般参数里有) 123456let currentNode = listlet currentPosition = 0while(currentNode !==null &amp;&amp; currentPosition &lt; position -1)&#123; currentNode = currentNode.next currentPosition++&#125; 增删改都是这样 记得判断链表为空的情况 记得判断给定位置在开头的情况 123if (position === 0) &#123; //xxxx&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"算法/链表","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"}],"tags":[]},{"title":"引入tailwind,className","slug":"引入tailwind-className","date":"2024-10-02T11:48:10.000Z","updated":"2024-10-02T12:34:48.835Z","comments":true,"path":"2024/10/02/引入tailwind-className/","permalink":"https://0922wx.github.io/2024/10/02/%E5%BC%95%E5%85%A5tailwind-className/","excerpt":"","text":"我用postcss插件，所以从Using PostCSS开始 12npm install -D tailwindcss postcss autoprefixernpx tailwindcss init 顺着官网就行了，只要注意main.css必须在src下 修改配置 1234567891011/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */module.exports = &#123; content: [&quot;./src/**/*.&#123;html,js,jsx,ts,tsx&#125;&quot;], theme: &#123; extend: &#123;&#125;, &#125;, plugins: [], corePlugins:&#123; preflight: false, &#125;&#125; 1npm install classnames 截至到此，已经完成初始化，以及绑定npm账号并已把组件库发布至npm的账号上了 回想一下遇到的奇事 1.package.json里的配置配错了 &quot;types&quot;: &quot;dist/index.d.ts&quot;写成了&quot;types&quot;: &quot;dist/type/index.d.ts&quot;, 导致我下载引入组件时报错，说找不到模块类型类型。 2.组件源码的src/index.ts没有导出任何组件，导致报错，别处下载引用时必须要带上wx-desginui/xx/xx/xx。 3.classNames和tailwind写的样式，有时候挺玄学的，如果双引号里稍微打个空格，或者没打空格，都会导致样式可能渲染不出来捏。 4.从原始人到现代人的过程：最开始调试样式或者测试组件功能时，仅通过发布npm更新，然后在别处下载引用通过这样子调试。这绝对不是什么常用的方法，于是我找到了另一种方法，不需要发布更新而在本地调试的方法： npm link 这需要另一个应用程序，这个方法还另有一个缺点：时间长了会断连接，需要重新连接。于是，找到了最新的方法：Storybook，仅本地调试，不需要再开另一个应用了。","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"组件库","slug":"项目/组件库","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"事前准备","slug":"项目/组件库/事前准备","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"}],"tags":[]},{"title":"写组件库，从第一个按钮开始编","slug":"写组件库，从第一个按钮开始编","date":"2024-10-02T11:45:11.000Z","updated":"2024-10-02T12:38:57.646Z","comments":true,"path":"2024/10/02/写组件库，从第一个按钮开始编/","permalink":"https://0922wx.github.io/2024/10/02/%E5%86%99%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%8C%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E5%BC%80%E5%A7%8B%E7%BC%96/","excerpt":"","text":"写一个组件？就我现在知道的事，应该分这几点 写好props类型，props的数量决定组件的自由度 没了 感觉无非就是先写一下interface，然后当作props传入组件就行了 比如我这个按钮，当然，简单的组件并不能说明什么，那些日历什么的倒真是麻烦得不行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React from &quot;react&quot;;import classNames from &quot;classnames&quot;;export interface ButtonProps &#123; title?: string; variant?: &quot;outlined&quot; | &quot;contained&quot;; onClick?: () =&gt; void; children?: React.ReactNode; disabled?: boolean; size?: &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;; rounded?: &quot;none&quot; | &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;; icon?: React.ReactNode; iconPosition?: &quot;left&quot; | &quot;right&quot;;&#125;function Button(props: ButtonProps) &#123; const &#123; title, onClick, children, variant = &quot;contained&quot;, disabled, size = &quot;medium&quot;, rounded = &quot;small&quot;, icon, iconPosition = &quot;left&quot; &#125; = props; return ( &lt;button onClick=&#123;onClick&#125; className=&#123;classNames(&quot;px-2 cursor-pointer shadow-none text-sm&quot;, &#123; &quot;border-2 border-solid border-black bg-white text-black&quot;: variant === &quot;outlined&quot;, &quot; bg-black text-white border-none&quot;: variant === &quot;contained&quot;, &quot;pointer-events-none cursor-not-allowed pointer-event-none bg-gray-300 border-none &quot;: disabled, &quot;h-8&quot;: size === &quot;small&quot;, &quot;h-10&quot;: size === &quot;medium&quot;, &quot;h-12&quot;: size === &quot;large&quot;, &quot;rounded-none&quot;: rounded === &quot;none&quot;, &quot;rounded-sm&quot;: rounded === &quot;small&quot;, &quot;rounded-md&quot;: rounded === &quot;medium&quot;, &quot;rounded-lg&quot;: rounded === &quot;large&quot;, &quot;flex gap-3 items-center&quot;:icon, &quot;flex-row-reverse&quot;:icon &amp;&amp; iconPosition === &quot;right&quot; &#125;)&#125; &gt; &#123;icon &amp;&amp; icon&#125; &#123;title || children&#125; &lt;/button&gt; );&#125;export default Button;","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"组件库","slug":"项目/组件库","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/"}],"tags":[]},{"title":"rollup基本构建","slug":"rollup基本构建","date":"2024-10-02T05:04:51.000Z","updated":"2024-10-06T10:10:33.607Z","comments":true,"path":"2024/10/02/rollup基本构建/","permalink":"https://0922wx.github.io/2024/10/02/rollup%E5%9F%BA%E6%9C%AC%E6%9E%84%E5%BB%BA/","excerpt":"","text":"从npm init开始编 1npm i react typescript @types/react tslib --save-dev 新建tsconfig.json 1234567891011121314151617181920&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;esModuleInterop&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;noFallthroughCasesInSwitch&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;noEmit&quot;: true, &quot;jsx&quot;: &quot;react-jsx&quot; &#125;, &quot;include&quot;: [&quot;src&quot;]&#125; 构建rollup 1npm i react typescript @types/react ts-lib --save-dev 12345678rollup //构建源代码并输出，起点@rollup/plugin-typescript //处理ts语法与转换@rollup/plugin-node-resolve //解析插件,把模块转化成js@rollup/plugin-commonjs //将commonjs转换成es6语法rollup-plugin-dts //生成类型文件的ts插件 生成组件的类型@rollup/plugin-terser //最小化代码rollup-plugin-peer-deps-external //排除指定的npm模块，对等依赖tslib rollup.config.ts 123456789101112131415161718192021222324252627282930313233343536import resolve from &quot;@rollup/plugin-node-resolve&quot;;import commonjs from &quot;@rollup/plugin-commonjs&quot;;import typescript from &quot;@rollup/plugin-typescript&quot;;import terser from &quot;@rollup/plugin-terser&quot;;import peerDeps from &quot;rollup-plugin-peer-deps-external&quot;;import &#123; dts &#125; from &quot;rollup-plugin-dts&quot;;export default [ &#123; input: &quot;src/index.ts&quot;, // 入口文件 output: [ &#123; file: &quot;dist/cjs/index.js&quot;, format: &quot;cjs&quot;, sourcemap: true, &#125;, //cjs &#123; file: &quot;dist/esm/index.js&quot;, format: &quot;esm&quot;, sourcemap: true, &#125;, //esm ], plugins: [ peerDeps(), //解决对等依赖关系 resolve(), // 解析node_modules中的模块 commonjs(), // 转换commonjs模块 typescript(), // 编译typescript terser(), //压缩代码 ], &#125;, &#123; input: &quot;src/index.ts&quot;, // 类型入口文件 output: [&#123; file: &quot;dist/index.d.ts&quot;, format: &quot;es&quot; &#125;], // 生成类型 plugins: [dts()], // 编译类型文件 &#125;,]; package.json 123456789101112131415161718192021222324252627282930&#123; &quot;name&quot;: &quot;wx-ui&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;dist/cjs/index.js&quot;, &quot;module&quot;: &quot;dist/esm/index.js&quot;, &quot;types&quot;: &quot;dist/index.d.ts&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;rollup -c --bundleConfigAsCjs&quot; &#125;, &quot;author&quot;: &quot;wx&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;description&quot;: &quot;&quot;, &quot;devDependencies&quot;: &#123; &quot;@types/react&quot;: &quot;^18.3.10&quot;, &quot;react&quot;: &quot;^18.3.1&quot;, &quot;ts-lib&quot;: &quot;^0.0.5&quot;, &quot;typescript&quot;: &quot;^5.6.2&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;@rollup/plugin-commonjs&quot;: &quot;^28.0.0&quot;, &quot;@rollup/plugin-node-resolve&quot;: &quot;^15.3.0&quot;, &quot;@rollup/plugin-terser&quot;: &quot;^0.4.4&quot;, &quot;@rollup/plugin-typescript&quot;: &quot;^12.1.0&quot;, &quot;rollup&quot;: &quot;^4.23.0&quot;, &quot;rollup-plugin-dts&quot;: &quot;^6.1.1&quot;, &quot;rollup-plugin-peer-deps-external&quot;: &quot;^2.2.4&quot;, &quot;tslib&quot;: &quot;^2.7.0&quot; &#125;&#125; npm run build 成功后生成dist文件夹(cjs,esm,index.d.ts)","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"组件库","slug":"项目/组件库","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"事前准备","slug":"项目/组件库/事前准备","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"}],"tags":[]},{"title":"完成imagekit认证前置","slug":"完成imagekit认证前置","date":"2024-10-01T06:39:43.000Z","updated":"2024-10-01T07:00:02.013Z","comments":true,"path":"2024/10/01/完成imagekit认证前置/","permalink":"https://0922wx.github.io/2024/10/01/%E5%AE%8C%E6%88%90imagekit%E8%AE%A4%E8%AF%81%E5%89%8D%E7%BD%AE/","excerpt":"","text":"依据ImageKit的官方文档，我们需要在后台SDK传入API公钥，私钥和URL端点，前面已经配置好了。 但是，想要将图片上传到imagekit的媒体库，还需要后端服务器用私有密钥对请求进行验证 怎么验证？ 使用imagekit-nestjs封装好的方法 我这里新建了user模块 1nest g resource user 123456789101112131415//user.controller.tsimport &#123; Controller, Get &#125; from &#x27;@nestjs/common&#x27;;import &#123; UserService &#125; from &#x27;./user.service&#x27;;@Controller(&#x27;user&#x27;)export class UserController &#123; constructor( private readonly userService: UserService) &#123;&#125; @Get(&#x27;keys&#x27;) async getImageKitKeys() &#123; const res = await this.userService.getAuthParameters(); return res; &#125;&#125; 1234567891011121314//user.service.tsimport &#123; Injectable &#125; from &#x27;@nestjs/common&#x27;;import &#123; ImageKitService &#125; from &quot;imagekit-nestjs&quot;;@Injectable()export class UserService &#123; constructor(private readonly imageKitService: ImageKitService) &#123;&#125; // 通过构造函数注入 ConfigService async getAuthParameters()&#123; // 获取 ImageKit 的认证参数 const keys = await this.imageKitService.getAuthenticationParameters(); return keys; // 返回密钥 &#125;&#125; 开启跨域 12345678910//main.tsimport &#123; NestFactory &#125; from &#x27;@nestjs/core&#x27;;import &#123; AppModule &#125; from &#x27;./app.module&#x27;;async function bootstrap() &#123; const app = await NestFactory.create(AppModule); app.enableCors(); await app.listen(3005);&#125;bootstrap(); 启动服务 1nest start 根据官方文档所说，如果成功的话会返回三个参数 用postman试一下 完成! 寥寥数笔，花了我三个多小时🫤 参考 CodeVisionEvgen/imagekit-nestjs: Imagekit nestjs module (github.com) React (imagekit.io) API keys (imagekit.io) Nest 通关秘籍 - zxg_神说要有光 - 掘金小册 (juejin.cn)","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"表情包制作","slug":"项目/表情包制作","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%A1%A8%E6%83%85%E5%8C%85%E5%88%B6%E4%BD%9C/"}],"tags":[]},{"title":"在nest中使用Imagekit.io","slug":"9-30","date":"2024-09-30T13:43:32.000Z","updated":"2024-10-01T03:33:11.247Z","comments":true,"path":"2024/09/30/9-30/","permalink":"https://0922wx.github.io/2024/09/30/9-30/","excerpt":"","text":"nest中构建imagekit.io服务 1npm install imagekit-nestjs 1npm install @nestjs/config 创建configs/imagekit.config.ts 12345678910import &#123; ConfigService &#125; from &quot;@nestjs/config&quot;;import &#123; ImageKitModuleOptions &#125; from &quot;imagekit-nestjs&quot;;export const ImageKitConfig = ( configService: ConfigService): ImageKitModuleOptions =&gt; (&#123; privateKey: configService.get(&quot;IMAGEKIT_PRIVATE_KEY&quot;), publicKey: configService.get(&quot;IMAGEKIT_PUBLIC_KEY&quot;), urlEndpoint: configService.get(&quot;IMAGEKIT_URL_ENDPOINT&quot;),&#125;); 根目录下创建.env文件 123IMAGEKIT_PUBLIC_KEY=&#x27;&#x27;IMAGEKIT_PRIVATE_KEY=&#x27;&#x27;IMAGEKIT_URL_ENDPOINT=&#x27;&#x27; 在AppModule中注入,允许环境变量全局可用 123456789101112131415161718192021222324import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;import &#123; AppController &#125; from &#x27;./app.controller&#x27;;import &#123; AppService &#125; from &#x27;./app.service&#x27;;import &#123; ConfigModule, ConfigService &#125; from &#x27;@nestjs/config&#x27;;import &#123; ImageKitModule &#125; from &#x27;imagekit-nestjs&#x27;;import &#123; ImageKitConfig &#125; from &#x27;./configs/imagekit.config&#x27;;@Module(&#123; imports: [ ConfigModule.forRoot(&#123; isGlobal: true, &#125;), ImageKitModule.forRootAsync(&#123; useFactory: ImageKitConfig, inject: [ConfigService], imports: [ConfigModule], isGlobal: true, // is optional &#125;), ], controllers: [AppController], providers: [AppService],&#125;)export class AppModule &#123;&#125; 完成 一些错误 报错 Error: Missing publicKey during ImageKit initialization 控制台打印后发现publickey和private都是undefined 这里是因为没有创建.env设置变量，而且没有把他变成全局可用导致的","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"表情包制作","slug":"项目/表情包制作","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%A1%A8%E6%83%85%E5%8C%85%E5%88%B6%E4%BD%9C/"}],"tags":[]},{"title":"迪火一面","slug":"迪火一面","date":"2024-09-27T08:25:18.000Z","updated":"2024-09-27T08:47:27.454Z","comments":true,"path":"2024/09/27/迪火一面/","permalink":"https://0922wx.github.io/2024/09/27/%E8%BF%AA%E7%81%AB%E4%B8%80%E9%9D%A2/","excerpt":"","text":"第一次面试记录 迪火 一面 半个小时 提问没按顺序排 自我介绍 JS基本数据类型 判断数组有几种方法 你刚刚提到了call，call的作用是什么？(绑定this指向)，call和apply有什么区别？ 主题切换可以怎么做？ antd组件怎么导入的？如果我导入组件时只写from 'antd',组件还能成功导入吗？打包会把所有东西都打包吗？ rem和em有什么区别？ 如何避免样式类名污染？(module.css)，原理？(给类名一个唯一值) 用过vue吗，vue是如何处理样式类名污染的？(scope)原理？ 如何让一个弹窗居中 开发中的Package.Lock.json有什么作用？ Package.json里的^和~的作用？ react条件渲染时为什么要加个key值？(优化diff算法)不加key会报错吗？ 用过redux吗，解释一下他的工作流程 如果有很多条数据需要以列表渲染，该怎么做（虚拟列表，byd没好好看结果问到了） 项目相关 做项目遇到的难点","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"反思三道动态规划题","slug":"反思三道动态规划题","date":"2024-09-27T05:57:21.000Z","updated":"2024-09-27T08:25:28.967Z","comments":true,"path":"2024/09/27/反思三道动态规划题/","permalink":"https://0922wx.github.io/2024/09/27/%E5%8F%8D%E6%80%9D%E4%B8%89%E9%81%93%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98/","excerpt":"","text":"先了解一点，动态规划(Dynamic Programming)是一种思路，将一个复杂的问题分解为更简单的子问题，通过对每个子问题只求解一次并存储结果，这是一个自底向上的过程，通过定位已知和未知之间的关系来进行推导。 从本质上讲，这是一个简单的想法，在用给定的输入解决一个问题后，将结果保存为参考，以便将来使用，这样你就不必重新解决问题了…简而言之，就是 &quot;记住你的过去&quot;🫠。 这个方法可以用递归或者迭代算法来实现，递归算法是通过递归方式找到子问题的解决方案，迭代算法则是通过按特定顺序处理子问题来找到解决方案。(原地tp) 思路历程约等于递归+记忆搜索。当然，这和递归有区别，因为用递归的话，OJ会判定超时。 DP是如何工作的？ 确定子问题:将主要问题划分为更小而独立的子问题。 存储解决方案:解决每个子问题并将解决方案存储在表格或者数组中。 建立解决方案:使用存好的解决方案建立主要问题的解决方案。 避免冗余:通过存储解决方案，DP可确保每个子问题只需要求解一次，从而减小计算时间。 什么时候使用动态规划？ 两个必要条件: 最优子结构 重叠子问题 那么步骤呢？ 确定他是否属于动态规划问题。 找到状态表达式。（倒推的过程） 确定状态和状态转换的关系。 制表（或者备忘录，反正和记忆搜索大差不差，就是现存储一些算好的结果，空间换时间） 爬楼梯 题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 基于动态规划的思想分析 首先做到倒着分析，即: 定位到问题终点 站在终点的角度，思考后退的可能 这题为什么可以用动态规划？体现在——不管前面的决策如何，此后的状态必须基于当前状态的最优决策。比如爬楼梯，我们要想站在第n阶楼梯，该如何达到？无非两种情况：一种从n-1阶爬上来；一种是从n-2阶爬上来。即 f(n) = f(n-1) + f(n-2)(找到状态转移方程) 人话:站在n阶，往后退只能退一步或者两步，对于每一阶楼梯皆是如此。 f(n-2) = f(n-3) + f(n-4) f(n-3) = f(n-4) + f(n-5) … 这是一个重复计算的过程，也符合重叠子问题这一特征 可以把他转为一个树型模型 .pijlwrkebxng{zoom: 50%;} 解法 我们已经找到了状态转移方程 f(n) = f(n-1) + f(n-2) 以 f(1) 和 f(2) 为起点，不断求和，循环递增 n 的值，我们就能够求出f(n)了 1234567891011121314151617/*** @param &#123;number&#125; n* @return &#123;number&#125;*/const climbStairs = function(n) &#123; // 初始化状态数组 const dp = []; // 初始化已知值 dp[1] = 1; dp[2] = 2; // 动态更新每一层楼梯对应的结果 for(let i = 3;i &lt;= n;i++)&#123; dp[i] = dp[i-2] + dp[i-1]; &#125; // 返回目标值 return dp[n];&#125;; 分析技巧 递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系 结合记忆化搜索，明确状态转移方程 递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。 不同路径 题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（标记为 “Finish” ）。 问总共有多少条不同的路径？ 输入：m = 3, n = 7 输出：28 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向下 那么，先倒着分析，当前位置我们有哪些可选方向的 当前只能往下,dp[i][j] = dp[i-1][j] 当前只能往右,dp[i][j] = dp[i][j-1] 当前又能下又能右， dp[i][j]=dp[i][j−1]+dp[i−1][j] 那么状态转移方程势必为 1dp[i][j] = dp[m-1][n]+ dp[m][n-1] 为什么是-1？ 没有为什么，因为起点是(0,0)，总共m行n列。 接着找初始条件，也就是起点 1dp[0][0] = 1 为什么初始条件是这个？ 因为这是开始移动的起点，这个位置到自身的路径是唯一的。 (想一下，从(0,0)到(0,0)的方法是不是只有一种) 解法 123456789101112131415161718192021/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var uniquePaths = function (m, n) &#123; // 初始化一个 m x n 的二维数组 let f = Array.from(&#123; length: m &#125;, () =&gt; Array(n).fill(0)); f[0][0] = 1; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (i &gt; 0) &#123; f[i][j] += f[i - 1][j]; // 往下 &#125; if (j &gt; 0) &#123; f[i][j] += f[i][j - 1]; // 往右 &#125; &#125; &#125; return f[m - 1][n - 1];&#125; 还有一道晚点写 参考 Dynamic Programming or DP - GeeksforGeeks 前端算法与数据结构面试：底层逻辑解读与大厂真题训练 - 修言 - 掘金小册 (juejin.cn) 动态规划路径问题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"虚拟dom","slug":"虚拟dom","date":"2024-09-23T09:41:33.000Z","updated":"2024-09-23T10:05:26.190Z","comments":true,"path":"2024/09/23/虚拟dom/","permalink":"https://0922wx.github.io/2024/09/23/%E8%99%9A%E6%8B%9Fdom/","excerpt":"","text":"构思一下面试怎么回答这个问题。 为什么要使用虚拟dom 相对于操作真实dom更加方便（性能而言自然是操作真实的要好，因为那是命令式编程） 相比于innerHTML，虚拟dom在更新的时候比他性能更高（innerHTML需要销毁所有旧的dom ，再解析新的字符串，最后重新创建所有dom节点） 虚拟dom仅需要两层计算：用diff算法计算更新的节点，然后更新必要的dom就行了 总结：虚拟dom能够防止组件在重渲染时导致的性能恶化， 而且还能批量更新（收集多个更新操作然后一次性将这些更改应用到真实dom上） 减少不必要的dom操作， 跨平台","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[]},{"title":"9-21即将到来的第一次面试","slug":"9-21","date":"2024-09-21T10:03:57.000Z","updated":"2024-10-01T06:45:25.238Z","comments":true,"path":"2024/09/21/9-21/","permalink":"https://0922wx.github.io/2024/09/21/9-21/","excerpt":"","text":"9.24号有线上面试，紧张准备中– 无论是不是刷kpi，都应该认真面对。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"Bind Apply Call的区别","slug":"BAC","date":"2024-09-21T09:04:50.000Z","updated":"2024-09-21T10:03:04.284Z","comments":true,"path":"2024/09/21/BAC/","permalink":"https://0922wx.github.io/2024/09/21/BAC/","excerpt":"","text":"相通点:都可以改变this 指向 为什么要改变this指向？ 123456789var name = &quot;wx&quot;;let obj =&#123; name:&quot;abc&quot;, say:function() &#123; console.log(this.name); &#125;,&#125;;obj.say();//显示abcsetTimeout(obj.say,10);//显示wx (实际我把var换成let或者const就不会打印出什么东西，因为那不再是全局变量，而是块级，输出一片空白捏) 同样调用obj,say,为什么结果不同呢?（涉及this绑定规则） setTimeout所指向为window对象，其中的say方法是作为回调函数执行的，其中所传递的是函数的引用，并没有保留这个函数所属的对象，那么setTimeout调用函数时，其中的this取决于调用时的执行上下文(这里并没有指定上下文，所以10毫秒后在全局执行环境执行，浏览器自动绑定window。) 那么此时，如果想修改say方法中的this，就需要改变this指向了。 apply绑定this 123setTimeout(function()&#123; obj.say.apply(obj);&#125;,10);//输出abc 参数传递：参数是在调用新函数时传递给它的参数。 (将所有参数放到一个数组里去) 调用时立即执行方法 比如 123456789let obj =&#123; name:&quot;abc&quot;, say:function(param1,param2) &#123; console.log(param1 +&quot;,&quot; + param2 +&quot;,&quot;+ this.name); &#125;,&#125;;setTimeout(function() &#123; obj.say.apply(obj,[&quot;hello&quot;,&quot;world&quot;])&#125;,10) call绑定this 跟apply差不多，唯一的区别是他需要的参数并非是一个数组，而是依次传入 调用时立即执行方法 所以需要注意与参数一一对应。 123setTimeout(function() &#123; obj.say.call(obj,&quot;hello&quot;,&quot;world&quot;)&#125;,10) bind绑定this 与其他两者最大的区别是，bind返回值是一个新的函数 调用时不直接执行 12let newFun = obj.say.bind(obj,&quot;hello&quot;,&quot;world&quot;);newFun(); 也不需要一次性传入所有参数 12let newFun = obj.say.bind(obj);newFun(&quot;hello&quot;,&quot;world&quot;); this的绑定规则 this和函数定义的位置没有关系，只和调用者有关系 在运行时被绑定 1234567891011121314function foo()&#123; console.log(this);&#125;foo();//windowvar obj = &#123; name:&quot;wx&quot;, foo:foo&#125;obj.foo()// objfoo.call(&quot;abc&quot;) // string&#123; &quot;abc&quot; &#125; 隐式绑定 1.通过对象调用函数绑定this 谁直接调用foo()，this就指向谁。 当然，这有个前置条件：对象所调用的函数必须是对象的属性。 123456789function foo()&#123; console.log(this);&#125;var obj = &#123; name:&quot;wx&quot;, foo:foo&#125;obj.foo() 显式绑定 如果obj对象上没有定义某个方法，但又想通过obj这个对象来调用这个方法？ 也就是最上面的call,apply,bind了 new绑定this 123456function Student(name)&#123; console.log(this)// student &#123;&#125; this.name = name; &#125;var wx = new Student(&quot;abc&quot;);console.log(wx); //student&#123;name:&#x27;abc&#x27;&#125; 涉及面试题：new 关键字创建一个新对象的步骤？ 构造函数如何创建新对象？ 1.创建一个空对象。 2.空对象的-proto-属性指向构造函数的Prototype属性。 3.执行构造函数，如果构造函数中有this，则此this指向刚刚创建的空对象。 4.返回刚刚创建的对象。 返回值？ 在构造函数中，如果有return的话会返回什么？ 12345678910function Student(name)&#123; console.log(this) this.name = name; return &#123; name:&quot;我是对象&quot; &#125;&#125;var wx = new Student(&quot;abc&quot;);console.log(wx); // &#123;name:&quot;我是新对象&quot;&#125; 如果return的是对象，则直接返回对象 如果return的是基本类型，则return语句无效，仍然返回刚刚创建的新对象。 如果多种绑定都存在，优先级？ 隐式绑定和显式绑定同时存在，显式绑定优先级更高 new绑定优先级高于隐式绑定(隐式垫底了说是) new绑定优先级高于bind 总结：new &gt; 显式(bind)&gt;隐式","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"}],"tags":[]},{"title":"受控组件与非受控组件","slug":"受控组件与非受控组件","date":"2024-09-16T12:49:11.000Z","updated":"2024-09-16T12:57:16.001Z","comments":true,"path":"2024/09/16/受控组件与非受控组件/","permalink":"https://0922wx.github.io/2024/09/16/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/","excerpt":"","text":"今天用 shadn ui 的 form 组件，其中提到了这是个受控组件，起初我还没注意。后面调试的时候发现我一往 input 里面 写东西，控制台就疯狂报错 Warning: A component is changing an uncontrolled input of type text to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: 第一次在实际中遇到受控组件因为没有默认值报错，复习一下： 涉及到输入，就绕不开受控模式和非受控模式的概念。改变表单值只有两种情况： 用户去改变 value 或者代码去改变 value。 如果不能通过代码改表单值 value，那就是非受控，也就是不受我们控制。 但是代码可以给表单设置初始值 defaultValue。 代码设置表单的初始 value，但是能改变 value 的只有用户，代码通过监听 onChange 来拿到最新的值，或者通过 ref 拿到 dom 之后读取 value。 这种就是非受控模式。 反过来，代码可以改变表单的 value，就是受控模式。 value 由用户控制就是非受控模式，由代码控制就是受控模式。","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[]},{"title":"9-16又和项目搏斗了一天","slug":"9-16","date":"2024-09-16T12:46:53.000Z","updated":"2024-10-01T06:45:29.049Z","comments":true,"path":"2024/09/16/9-16/","permalink":"https://0922wx.github.io/2024/09/16/9-16/","excerpt":"","text":"完全不知道做什么捏，只是弄好了一个dashboard而已，然后加了个toDoList，后面再优化一下好了。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"9-13中秋节再冲一次吧","slug":"9-13","date":"2024-09-13T12:30:06.000Z","updated":"2024-10-01T06:45:31.427Z","comments":true,"path":"2024/09/13/9-13/","permalink":"https://0922wx.github.io/2024/09/13/9-13/","excerpt":"","text":"9月很重要啊，得再敲一个项目出来。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"9-8有那么一点点拨云见日了","slug":"9-8","date":"2024-09-08T12:04:03.000Z","updated":"2024-10-01T06:45:33.182Z","comments":true,"path":"2024/09/08/9-8/","permalink":"https://0922wx.github.io/2024/09/08/9-8/","excerpt":"","text":"跟着学了一个日历组件的搭建，稍微理清了props传值，usecontext，条件渲染这些东西了 还没弄完，先沉淀一下吧。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"事件循环","slug":"事件循环","date":"2024-09-07T05:55:53.000Z","updated":"2024-09-07T06:00:40.151Z","comments":true,"path":"2024/09/07/事件循环/","permalink":"https://0922wx.github.io/2024/09/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"事件循环包括三个部分： 1.主线程 2.宏队列：异步操作（如Ajax请求，定时器） 3.微队列：Promise回调等 顺序： 先执行主线程，遇到宏任务就放到宏队列，遇微任务放到微队列 主线程执行完毕，优先开始处理微队列，再执行宏队列，如此循环 事件循环是JavaScript非阻塞行为的关键。","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"}],"tags":[]},{"title":"9-6连滚带爬的做完了","slug":"9-6","date":"2024-09-06T12:28:15.000Z","updated":"2024-10-01T06:45:35.823Z","comments":true,"path":"2024/09/06/9-6/","permalink":"https://0922wx.github.io/2024/09/06/9-6/","excerpt":"","text":"没想到真的赶在开学前做好tutu会客室了，哇偶。 接下来就做组件库吧，这样就没有后端的烦恼了。 溜八股了，不过在此之中。 也需要大玩特玩星际战士。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"9-5噩耗：后天开学","slug":"9-5","date":"2024-09-05T13:12:03.000Z","updated":"2024-10-01T06:45:11.986Z","comments":true,"path":"2024/09/05/9-5/","permalink":"https://0922wx.github.io/2024/09/05/9-5/","excerpt":"","text":"伪人即将开学👽","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"天才的第一步","slug":"动态规划","date":"2024-09-04T12:02:31.000Z","updated":"2024-09-04T12:12:58.622Z","comments":true,"path":"2024/09/04/动态规划/","permalink":"https://0922wx.github.io/2024/09/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"首先记住两个特征： 1.要求给出达成某种目的的解法个数 2.不要求你给出每一种解法对应的具体路径 核心思想就是穷举求最值。 只有列出正确的状态转移方程，才能正确穷举，而且需要判断算法是否具备最优子结构是否能够通过子问题的最值得到原问题的最值。 外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。 (看不懂) 重叠子问题、最优子结构、状态转移方程就是动态规划三要素，动态规划是自底向上的过程，它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"9-2世界是一个巨大的蓝色链接","slug":"9-2","date":"2024-09-02T13:14:25.000Z","updated":"2024-10-01T06:44:33.493Z","comments":true,"path":"2024/09/02/9-2/","permalink":"https://0922wx.github.io/2024/09/02/9-2/","excerpt":"","text":"目前所有的算法知识来源于两个地方，一个叫labuladong的算法笔记(花了我两百大洋),一个是稀土掘金的前端数据结构与算法(四十大洋)。 这个算法笔记确实是全啊，但是每当我想按顺序看内容的时候，字里行间总会出现蓝色链接的字。我不点进去看吧，他说他已经在蓝字里总结这些知识，不看 总觉得亏，也不利于下文的理解；我点进去看吧，里面又是一堆蓝色链接👽。于是层层递进，层层嵌套，我便不停的点进去，像是中了DFS的毒。😵‍💫 世界是一个巨大的蓝色链接 (今天也是换了渲染引擎，可以发表情了)","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"二叉树前置思想","slug":"二叉树思路","date":"2024-09-02T12:40:03.000Z","updated":"2024-09-02T13:11:55.831Z","comments":true,"path":"2024/09/02/二叉树思路/","permalink":"https://0922wx.github.io/2024/09/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%9D%E8%B7%AF/","excerpt":"","text":"快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历。(听说高手都是这么想的) 所以先打点基础吧。 快排算法思路 代码框架 1234567891011const sort = function(nums, lo, hi) &#123; if (lo &gt;= hi) &#123; return; &#125; // 对 nums[lo..hi] 进行切分 // 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi] let p = partition(nums, lo, hi); // 去左右子数组进行切分 sort(nums, lo, p - 1); sort(nums, p + 1, hi);&#125;; 对比二叉树前序遍历 1234567891011// 二叉树遍历框架const traverse = function(root) &#123; if (root === null) &#123; return; &#125; // ***** 前序位置 ***** console.log(root.val); // ******************* traverse(root.left); traverse(root.right);&#125;; 一句话总结快速排序：快速排序是先将一个元素排好序，然后再将剩下的元素排好序。 快速排序的核心无疑是 partition 函数， partition 函数的作用是在 nums[lo..hi] 中寻找一个切分点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p] 一个元素左边的元素都比它小，右边的元素都比它大，所以 partition 函数干的事情，其实就是把 nums[p] 这个元素排好序了。 从二叉树的视角，我们可以把子数组 nums[lo..hi] 理解成二叉树节点上的值，sort 函数理解成二叉树的遍历函数。 partition 函数每次都将数组切分成左小右大两部分，恰好和二叉搜索树左小右大的特性吻合。 欸☝️🤓，那快速排序的过程可不就是是一个构造二叉搜索树的过程。 但是二叉搜索树不平衡的极端情况，需要引入随机性，比如洗牌算法。当然这种东西就不是现在的我能碰瓷的了，随便记一下就好了。 快速排序代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const quickSort = function(nums) &#123; // 排序整个数组（原地修改） sort(nums, 0, nums.length - 1);&#125;;const sort = function(nums, lo, hi) &#123; if (lo &gt;= hi) &#123; return; &#125; // 对 nums[lo..hi] 进行切分 // 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi] let p = partition(nums, lo, hi); sort(nums, lo, p - 1); sort(nums, p + 1, hi);&#125;;// 对 nums[lo..hi] 进行切分const partition = function(nums, lo, hi) &#123; let pivot = nums[lo]; // 关于区间的边界控制需格外小心，稍有不慎就会出错 // 这里把 i, j 定义为开区间，同时定义： // [lo, i) &lt;= pivot；(j, hi] &gt; pivot // [lo, i) &lt;= pivot; (j, hi] &gt; pivot // 之后都要正确维护这个边界区间的定义 let i = lo + 1, j = hi; // 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖 while (i &lt;= j) &#123; while (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123; i++; // 此 while 结束时恰好 nums[i] &gt; pivot &#125; while (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123; j--; // 此 while 结束时恰好 nums[j] &lt;= pivot &#125; if (i &gt;= j) &#123; break; &#125; // 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot // 交换 nums[j] 和 nums[i] [nums[i], nums[j]] = [nums[j], nums[i]]; // 此时 [lo, i] &lt;= pivot &amp;&amp; [j, hi] &gt; pivot &#125; // 最后将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大 [nums[lo], nums[j]] = [nums[j], nums[lo]]; return j;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"算法/二叉树","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[]},{"title":"React组件的TS类型","slug":"React组件的TS类型","date":"2024-09-02T12:10:34.000Z","updated":"2024-09-08T10:26:06.247Z","comments":true,"path":"2024/09/02/React组件的TS类型/","permalink":"https://0922wx.github.io/2024/09/02/React%E7%BB%84%E4%BB%B6%E7%9A%84TS%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"平时常用的类型在@types/react这个包里，cra已经引入了。 JSX类型 如果你想描述一个jsx类型，使用React.ReactElement。 比如 1234interface AaaProps &#123; name:string; content:React.Reactelement&#125; 这样就只能传入jsx类型 如果有时需要传入number,null呢？ 换成ReactNode就好了 1234interface AaaProps &#123; name:string; content:React.ReactNode&#125; ReactNode 包含 ReactElement、或者 number、string、null、boolean 等可以写在 JSX 里的类型。 这三个类型的关系 ReactNode &gt; ReactElement &gt; JSX.Element。 所以，一般情况下，如果你想描述一个参数接收 JSX 类型，就用 ReactNode 就行。 函数组件类型 FC 和 FunctionComponent 等价，参数是 Props，返回值是 ReactNode 1234567const Aaa:React.FunctionComponent&lt;AaaProps&gt; = (props) =&gt;&#123; return &lt;div&gt;aaa,&#123;props.name&#125;&#123;props.content&#125;&lt;/div&gt;&#125;function Aaa2(props:AaaProps) &#123; return &lt;div&gt;aaa,&#123;props.name&#125;&#123;props.content&#125;&lt;/div&gt;&#125; 类型定义 123456789type FC&lt;p = &#123;&#125;&gt; = FunctionComponent&lt;p&gt;interface FuctionComponent&lt;p = &#123;&#125;&gt; &#123; (props: P ,context?:any):ReactNode; propsTypes?: WeakValidationMap&lt;p&gt; | undefined; contextTypes?: ValidationMap&lt;p&gt; | undefined; defultProps?: Partial&lt;p&gt; | undefined; displayNmae?: string | undefined;&#125; Hook的类型 useState 一般用推导的类型，或者手动声明。 useEffect 和 useLayoutEffect 没有类型参数。 useRef 作为可以保存dom引用或者其他内容的钩子，它的类型有两种。 保存dom引用时，参数需要传个null，不然会报错 1const ref = useRef&lt;HTMLDivElement&gt;(null) 而保存别的内容的时候，不能传 null，不然也会报错，说是 current 只读,原因是当你传入 null 的时候，返回的是 RefObject，它的 current 是只读的。而不传 null 的时候，返回的 MutableRefObject，它的 current 就可以改了。因为 ref 既可以保存 dom 引用，又可以保存其他数据，而保存 dom 引用又要加上 readonly，所以才用 null 做了个区分。 **传 null 就是 dom 引用，返回 RefObject，不传就是其他数据，返回 MutableRefObject。**所以，这就是一种约定，知道传 null 和不传 null 的区别就行了。 参数类型 propsWithChildren 就是给 Props 加了一个 children 属性。 CSSProperties 有时候组件可以通过 props 传入一些 css 的值，这时候怎么写类型呢？ 用 CSSProperties。 HTMLAttributes 如果你写的组件希望可以当成普通 html 标签一样用，也就是可以传很多 html 的属性作为参数呢？ 那可以继承 HTMLAttributes。 ComponentProps 效果与HTMLAttributes一样。 EventHandler 很多时候，组件需要传入一些事件处理函数，这种参数就要用 xxxEventHandler 的类型，比如 MouseEventHandler、ChangeEventHandler 等，它的类型参数是元素的类型。 总结 ReactNode：JSX 的类型，一般用 ReactNode，但要知道 ReactNode、ReactElement、JSX.Element 的关系。 FunctionComonent：也可以写 FC，第一个类型参数是 props 的类型。 useRef 的类型：传入 null 的时候返回的是 RefObj，current 属性只读，用来存 html 元素；不传 null 返回的是 MutableRefObj，current 属性可以修改，用来存普通对象。 ForwardRefRenderFunction：第一个类型参数是 ref 的类型，第二个类型参数是 props 的类型。forwardRef 和它类型参数一样，也可以写在 forwardRef 上。 useReducer：第一个类型参数是 Reducer&lt;data 类型, action 类型&gt;，第二个类型参数是初始化函数的参数类型。 PropsWithChildren：可以用来写有 children 的 props。 CSSProperties： css 样式对象的类型。 HTMLAttributes：组件可以传入 html 标签的属性，也可以指定具体的 ButtonHTMLAttributes、AnchorHTMLAttributes。 ComponentProps：类型参数传入标签名，效果和 HTMLAttributes 一样。 EventHandler：事件处理器的类型。","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[]},{"title":"9-1高浓度赛博垃圾场","slug":"9-1","date":"2024-09-01T12:49:00.000Z","updated":"2024-10-01T06:44:31.568Z","comments":true,"path":"2024/09/01/9-1/","permalink":"https://0922wx.github.io/2024/09/01/9-1/","excerpt":"","text":"博客这种东西，除开一些技术记录，好像也就只有写写日记的功能了。但是正常人谁写日记啊？ ————看到一些荒废的博客有感而发。 所以放弃才是常事。 .lsewktxcjnfd{zoom:50%;} 说起来这个图片怎么这么大，看来我要找找缩小图片的方法了。。。 原来点一下右键就行了，，","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"括号问题","slug":"8-31","date":"2024-08-31T12:33:50.000Z","updated":"2024-09-01T12:18:29.712Z","comments":true,"path":"2024/08/31/8-31/","permalink":"https://0922wx.github.io/2024/08/31/8-31/","excerpt":"","text":"题目中若涉及括号问题，则很有可能和栈相关。","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"栈与队列","slug":"算法/栈与队列","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"}],"tags":[]},{"title":"8-30痛定思痛与继续打牌","slug":"8-30","date":"2024-08-30T11:52:07.000Z","updated":"2024-10-01T06:44:27.893Z","comments":true,"path":"2024/08/30/8-30/","permalink":"https://0922wx.github.io/2024/08/30/8-30/","excerpt":"","text":"明天真得看二叉树了吧，自从黑神话出前三天开始就一直在摸鱼，摸着摸着就到月底了。 学无止境捏。 唉，秋招。唉，春招。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"遗式时间线","slug":"遗式时间线","date":"2024-08-30T11:43:30.000Z","updated":"2024-10-01T06:45:55.885Z","comments":true,"path":"2024/08/30/遗式时间线/","permalink":"https://0922wx.github.io/2024/08/30/%E9%81%97%E5%BC%8F%E6%97%B6%E9%97%B4%E7%BA%BF/","excerpt":"","text":"接触遗式 第一天：美丽强大的海仙女，回手怪效康，还是高贵的康回卡组，我直呼强大。 第二天：我会平等的解放每一个让我开出冰魔镜的人。 第三天：两卡动，本家就一个冷酷一卡动一卡停，还是得靠雷精起场子。 第四天：小时候看到这集为了召唤海仙女扣了3000血。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"游戏王","slug":"日常/游戏王","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B8%B8%E6%88%8F%E7%8E%8B/"}],"tags":[]},{"title":"领悟链表节点","slug":"一张图明了链表","date":"2024-08-30T11:29:38.000Z","updated":"2024-08-30T11:42:36.875Z","comments":true,"path":"2024/08/30/一张图明了链表/","permalink":"https://0922wx.github.io/2024/08/30/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%98%8E%E4%BA%86%E9%93%BE%E8%A1%A8/","excerpt":"","text":"之前总是没理解为什么这个时候操作val,那个时候操作next。直到看到这幅图。哦，这下看懂了。","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"算法/链表","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"}],"tags":[]},{"title":"8-29切合实际与不切实际的幻想时间","slug":"8-29","date":"2024-08-29T12:04:38.000Z","updated":"2024-10-01T06:44:21.228Z","comments":true,"path":"2024/08/29/8-29/","permalink":"https://0922wx.github.io/2024/08/29/8-29/","excerpt":"","text":"8月29日 希望能在开学前敲好秃秃会客室，然后稍加总结。秋招寄了就春招，再寄就去住桥洞。 六级最好也在这学期过了，目标是500左右。 有活的话，想在上班的同时准备一下考研。 九月还有星际战士玩，好。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"快慢指针","slug":"双指针","date":"2024-08-29T02:06:58.000Z","updated":"2024-08-29T11:46:13.682Z","comments":true,"path":"2024/08/29/双指针/","permalink":"https://0922wx.github.io/2024/08/29/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"链表题目简单分为三类： 链表的处理：合并，删除等 链表的反转以及衍生 链表成环及其衍生 做链表处理类问题需要把握一个中心思想——即处理链表的本质，就是处理链表节点之间的指针关系。 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分两类：左右指针和快慢指针。 左右指针，即两个指针相向或者相背而行；快慢指针，即两个指针同向而行，一块一慢。 对于单链表，大部分技巧都属于快慢指针；对于数组，我们把索引当作数组中的指针。 快慢指针技巧 原地修改 数组中常见的快慢指针技巧，比如原地修改数组 26. 删除有序数组中的重复项 | 力扣 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 高效解决这道题就要用到快慢指针技巧： 让慢指针slow走在后面，快指针fast走在前面探路，找到一个不重复的元素就赋值给slow并让slow前进一步。 这样就保证了nums[0…slow]都是无重复元素，fast遍历完整个数组后，nums[0…slow]即是整个数组去重的结果。 12345678910111213141516var removeDuplicates = function(nums) &#123; if (nums.length == 0) &#123; return 0; &#125; let slow = 0, fast = 0; while (fast &lt; nums.length) &#123; if (nums[fast] != nums[slow]) &#123; slow++; // 维护 nums[0..slow] 无重复 nums[slow] = nums[fast]; &#125; fast++; &#125; // 数组长度为索引 + 1 return slow + 1;&#125;; 力扣第83题「删除排序链表中的重复元素」，链表去重与数组去重相似，唯一的区别是把数组赋值操作变成操作指针而已。 1234567891011121314var deleteDuplicates = function(head) &#123; if(head === null) return null let fast =head,slow = head while(fast !==null)&#123;​ if(fast.val !== slow.val)&#123;​ slow.next = fast​ slow = slow.next​ &#125;​ fast++ &#125; // 断开与后面重复元素的连接 slow.next = null; return head;&#125;; (说起来，去重数组用Set()在力扣居然也能通过。) 滑动窗口 暂时不会，会了再说吧","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"算法/双指针","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[]},{"title":"浅拷贝与深拷贝","slug":"Deep-and-Shallow-Copy","date":"2024-08-27T16:00:00.000Z","updated":"2024-09-02T12:11:48.087Z","comments":true,"path":"2024/08/28/Deep-and-Shallow-Copy/","permalink":"https://0922wx.github.io/2024/08/28/Deep-and-Shallow-Copy/","excerpt":"","text":"记录于7月3号，语雀 首先明确JS的数据类型能分成基本数字类型和引用类型 1234let a =10;let b =a;a =100;console.log(b); //结果为10 基本数字类型之间拷贝传递的就是值。在栈中，声明一个变量a，再将a赋值给b，此时栈中a=10，b=10，两者相互独立，所以a值的修改并不影响b。 1234let a =[1,2,3,4];let b =a;a[0] =100;console.log(b); //结果为[100,2,3,4] 我们修改了数组a，却也影响了数组b，引用类型的值(栈中)存放的并非数值本身，而是内存地址，仅拷贝地址，就是浅拷贝。 一些深拷贝的方法 1234567let a =[1,2,3,4];let b =[...a];a[0] =100;console.log(b);console.log(a);//b:[1,2,3,4]//a:[100,2,3,4] 从内存里面开辟一块新的空间存放数组，利用展开运算符把a的每一项存入数组中，虽然有效，然有其局限，遇上多维数组就不管用了。 为什么不管用？ 二维数组内的数组仍然是引用类型，对应另一个地址存储了这个数组。虽然我们经过了拷贝，在堆里开辟一个新空间存储给b，但是001中的二维数组存的就是一个地址，所以新开辟的空间拿到的也是一个地址。 所以我们要想办法实现多层拷贝，各自开辟独立空间，互不干扰。 如果是基本类型数据，他们的拷贝就是深拷贝；对于引用类型数据，不论数据是一层还是多层，只要把内部的引用类型数据全部独立开辟内存空间，数据完全互不干扰，就是深拷贝，只要有共用数据就是浅拷贝。 多层拷贝 常用方法:Json格式转化 123456let a =[1,2,3,4,[5,6,&#123;name:&#x27;wx&#x27;&#125;]];let b =JSON.parse(stringify(a));console.log(b);console.log(typeof b);//[1,2,3,4[5,6,&#123;name:&#x27;wx&#x27;&#125;]]//object 为数不多的缺点就是无法转化拷贝函数类型(这真的是我要考虑的东西吗)。 所以说，接下来就是实现函数的拷贝。 如果没有嵌套数据，使用展开运算符即可解决，能解决的原因是这里修改一个函数等于重写一个函数，重写就会在内存里开辟一个新空间。所以，如果我们的数据里没有嵌套数组和对象，又有函数，是可以直接用展开运算符来拷贝的(好用，爱用，虽然我还没有实际用到过)。 12345678910let a =&#123; name:&#x27;wx&#x27;, age:18, fn()&#123; console.log(this.name); &#125; &#125;let b =&#123;...a&#125;;console.log(&quot;a为:&quot;,a); //&#123;name:&#x27;wx&#x27;,age:18,fn:f&#125;console.log(&quot;b为:&quot;,b); //&#123;name:&#x27;wx&#x27;,age:18,fn:f&#125; 手写一个递归实现相对完美的深拷贝 12345678910111213function deepClone(oldData)&#123; //进入循坏条件为数组或者对象,具体是什么得继续判断 if(typeof oldData === &#x27;object&#x27; &amp;&amp; oldData !== null)&#123; //如果是数组就新建一个新数组，否则就新建一个对象 let res =Array.isArray(oldData)? [] : &#123;&#125;; for(let k in oldData)&#123; res[k] = deepClone(oldData[k]); &#125; return res; &#125;else&#123; return oldData; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"}],"tags":[]},{"title":"","slug":"初衷","date":"2024-08-27T16:00:00.000Z","updated":"2024-10-11T14:42:32.986Z","comments":true,"path":"2024/08/28/初衷/","permalink":"https://0922wx.github.io/2024/08/28/%E5%88%9D%E8%A1%B7/","excerpt":"","text":"当时已惘然,这时也惘然 🕕🤖👾⛄🕦","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]}],"categories":[{"name":"TS类型体操","slug":"TS类型体操","permalink":"https://0922wx.github.io/categories/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"},{"name":"简单题","slug":"TS类型体操/简单题","permalink":"https://0922wx.github.io/categories/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/%E7%AE%80%E5%8D%95%E9%A2%98/"},{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"},{"name":"ThreeJs","slug":"前端/ThreeJs","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/ThreeJs/"},{"name":"事前准备","slug":"前端/ThreeJs/事前准备","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/ThreeJs/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"},{"name":"css","slug":"前端/css","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/css/"},{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"},{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"},{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"算法/链表","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"组件库","slug":"项目/组件库","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"事前准备","slug":"项目/组件库/事前准备","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"},{"name":"表情包制作","slug":"项目/表情包制作","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%A1%A8%E6%83%85%E5%8C%85%E5%88%B6%E4%BD%9C/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"React","slug":"前端/React","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"二叉树","slug":"算法/二叉树","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"栈与队列","slug":"算法/栈与队列","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"name":"游戏王","slug":"日常/游戏王","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B8%B8%E6%88%8F%E7%8E%8B/"},{"name":"双指针","slug":"算法/双指针","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[]}