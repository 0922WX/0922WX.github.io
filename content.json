{"meta":{"title":"WX'sMajula","subtitle":null,"description":null,"author":"王潇","url":"https://0922wx.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-08-28T12:30:36.000Z","updated":"2024-10-25T15:32:27.388Z","comments":true,"path":"about/index.html","permalink":"https://0922wx.github.io/about/index.html","excerpt":"","text":"Majula这个名字出自黑暗之魂2,意为被遗忘遗弃之地。 就是这样。 如蜜确实好看啊,我怎么就不能住如蜜呢"},{"title":"分类","date":"2024-08-28T10:57:19.000Z","updated":"2024-08-28T11:30:11.761Z","comments":true,"path":"categories/index.html","permalink":"https://0922wx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"TS重载","slug":"TS重载","date":"2024-11-12T10:26:12.000Z","updated":"2024-11-12T10:54:43.256Z","comments":true,"path":"2024/11/12/TS重载/","permalink":"https://0922wx.github.io/2024/11/12/TS%E9%87%8D%E8%BD%BD/","excerpt":"","text":"【前端必备】用了 TS 条件类型，同事直呼 YYDS！_哔哩哔哩_bilibili 在此之前，先了解 条件类型 T extends U ? X:Y T,U,X,Y都是类型占用符，爱怎么写怎么写 这句话的意思是，当类型T可以赋值给类型U时，那么返回类型X，否则返回类型Y type IsString&lt;T&gt; = T extends string ? true : false; type I0 = IsString&lt;number&gt; //false 12345678910111213type IsString&lt;T&gt; = T extends string ? true : false;type I0 = IsString&lt;number&gt; //falsetype TypeName&lt;T&gt; = T extends string ? &quot;string&quot; : T extends number ? &quot;number&quot; : T extends boolean ? &quot;boolean&quot; : T extends undefined ? &quot;undefined&quot; : T extends Function ? &quot;function&quot; : &quot;object&quot;;type T10 = TypeName&lt;string | (() =&gt;void)&gt; //type T10 = &quot;string&quot; | &quot;function&quot; 如果传入联合类型，返回联合类型？ 这里的TypeName属于分布式条件类型，在这之中 如果被检查的类型T为 裸类型参数（分布式条件类型，即没有被数组 元组 promise包裹） 当传入联合类型，就被分解成多个分支 infer 用于声明类型变量已存储在模式匹配过程中的所捕获的类型 type UnpackedArray&lt;T&gt; = T extends (infer U)[] ? U : T; infer用于存储被推断的类型 123type UnpackedArray&lt;T&gt; = T extends (infer U)[] ? U : T;type T4 = string[];type T5 = UnpackedArray&lt;T4&gt;// string","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Typescript","slug":"前端/Typescript","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Typescript/"}],"tags":[]},{"title":"11-6","slug":"11-6","date":"2024-11-06T15:55:14.000Z","updated":"2024-11-06T15:58:09.666Z","comments":true,"path":"2024/11/06/11-6/","permalink":"https://0922wx.github.io/2024/11/06/11-6/","excerpt":"","text":"多少沾点自娱自乐了","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"TS工具类型","slug":"TS工具类型","date":"2024-10-31T11:10:32.000Z","updated":"2024-10-31T11:26:05.646Z","comments":true,"path":"2024/10/31/TS工具类型/","permalink":"https://0922wx.github.io/2024/10/31/TS%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"也是被问了两次了 Awaited&lt;Type&gt;:用来取出 Promise 的返回值类型，适合用在描述then()方法和 await 命令的参数类型。 Partial：将所有类型设置为可选Partial&lt;A&gt; Required:所有属性必选 readonly：将属性标记为只读 Record:声明属性名还未确定的接口类型 Awaited Awaited&lt;Type&gt; 12// stringtype A = Awaited&lt;Promise&lt;string&gt;&gt;; //Awaited&lt;Type&gt;会返回 Promise 的返回值类型（string） 还能返回多重promise的返回值类型 12// numbertype B = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;; 如果它的类型参数不是 Promise 类型，那么就会原样返回 12// number | booleantype C = Awaited&lt;boolean | Promise&lt;number&gt;&gt;; ConstructorParameters ConstructorParameters&lt;Type&gt;提取构造方法Type的参数类型，组成一个元组类型返回。也就是用来获取构造函数的构造参数 最看不懂的一集 12type T1 = ConstructorParameters&lt;new (x: string, y: number) =&gt; object&gt;; // [x: string, y: number]type T2 = ConstructorParameters&lt;new (x?: string) =&gt; object&gt;; // [x?: string | undefined] 可以返回一些内置构造方法的参数类型 123type T1 = ConstructorParameters&lt;ErrorConstructor&gt;; // [message?: string]type T2 = ConstructorParameters&lt;FunctionConstructor&gt;; // string[]type T3 = ConstructorParameters&lt;RegExpConstructor&gt;; // [pattern:string|RegExp, flags?:string] 参数类型不是构造方法，就会报错 Record Record&lt;K,T&gt;构造具有给定类型T的一组属性K的类型。在将一个类型的属性映射到另一个类型的属性时，Record非常方便。 12345678type UserProps = &#x27;name&#x27; | &#x27;job&#x27; | &#x27;email&#x27;;// 等价于你一个个实现这些属性了type User = Record&lt;UserProps, string&gt;;const user: User = &#123; name: &#x27;John Doe&#x27;, job: &#x27;fe-developer&#x27;, email: &#x27;john.doe@example.com&#x27;&#125;; Pick Pick:接收一个对象类型，以及一个字面量类型组成的联合类型，这个联合类型只能是由对象类型的属性名组成的。它会对这个对象类型进行裁剪，只保留你传入的属性名组成的部分 12345678type User = &#123; name: string; age: number; email: string; phone: string;&#125;;// 只提取其中的 name 与 age 信息type UserBasicInfo = Pick&lt;User, &#x27;name&#x27; | &#x27;age&#x27;&gt;; Omit Omit:就是 Pick 类型的另一面，它的入参和 Pick 类型一致，但效果却是相反的——它会移除传入的属性名的部分，只保留剩下的部分作为新的对象类型 123456789type User = &#123; name: string; age: number; email: string; phone: string;&#125;;// 只移除 phone 属性type UserWithoutPhone = Omit&lt;User, &#x27;phone&#x27;&gt;; Exclude和Extract Exclude 和Extract:差集和交集 12345type UserProps = &#x27;name&#x27; | &#x27;age&#x27; | &#x27;email&#x27; | &#x27;phone&#x27; | &#x27;address&#x27;;type RequiredUserProps = &#x27;name&#x27; | &#x27;email&#x27;;// OptionalUserProps = UserProps - RequiredUserPropstype OptionalUserProps = Exclude&lt;UserProps, RequiredUserProps&gt;;const optionalUserProps: OptionalUserProps = &#x27;age&#x27;; // &#x27;age&#x27; | &#x27;phone&#x27; | &#x27;address&#x27;; 1234type UserProps = &#x27;name&#x27; | &#x27;age&#x27; | &#x27;email&#x27; | &#x27;phone&#x27; | &#x27;address&#x27;;type RequiredUserProps = &#x27;name&#x27; | &#x27;email&#x27;;type RequiredUserPropsOnly = Extract&lt;UserProps, RequiredUserProps&gt;;const requiredUserPropsOnly: RequiredUserPropsOnly = &#x27;name&#x27;; // &#x27;name&#x27; | &#x27;email&#x27;;","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Typescript","slug":"前端/Typescript","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Typescript/"}],"tags":[]},{"title":"10-25两种状态","slug":"10-25","date":"2024-10-25T15:18:31.000Z","updated":"2024-10-25T15:23:31.321Z","comments":true,"path":"2024/10/25/10-25/","permalink":"https://0922wx.github.io/2024/10/25/10-25/","excerpt":"","text":"嫌弃面试问题问得太怪的，不招人纯为了kpi问点怪题罢了。 嫌弃面试问题问得简单的，不招人纯为了kpi唠点家常罢了。 一想到面半天薪资3k就气笑了。 啊，让人无语的世界。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"奇点云","slug":"奇点云","date":"2024-10-25T07:45:17.000Z","updated":"2024-10-29T07:52:23.330Z","comments":true,"path":"2024/10/25/奇点云/","permalink":"https://0922wx.github.io/2024/10/25/%E5%A5%87%E7%82%B9%E4%BA%91/","excerpt":"","text":"汗流浃背(褒义) 之前实习过吗(没有,感觉已经寄80%了) 介绍一下常用布局 选择器优先级 介绍一下定位 absolute 设置top:10px会发生什么 JS的异步方法 await后面都能跟些什么 TS的特点 TS的数据类型 TS怎么类型声明 TS的interface和type的区别 TS的工具类 div包裹div，外层div的内联样式会影响到内部吗 写过自定义Hook吗 less和sass的优点 ==和===的区别 []==[]会发生什么(false) react常用的HOOKS Hooks的执行顺序 (完全不知道捏) 第一个useeffect的依赖项[a],第二个useeffect依赖项[a,b]，a变化时会一起触发渲染吗 sql语句(不会) linux常用命令 213 首先，React 会执行组件的函数体，开始渲染过程。在这个阶段，使用 useMemo 和 useCallback 的代码会被执行。 useMemo 会根据依赖项的变化来计算并返回缓存的值。如果依赖项没有变化，则返回之前缓存的值。 useCallback 会根据依赖项的变化返回一个缓存的函数引用。如果依赖项没有变化，则返回之前的函数引用。 DOM 更新： 在渲染过程结束后，React 会进行 DOM 更新，将计算得到的值和组件的渲染结果应用到 DOM 中。 副作用处理： 在所有的渲染和 DOM 更新完成后，React 才会执行 useEffect 中定义的副作用函数。如果组件在这一过程中被卸载，相关的清理函数（如果定义了）也会被调用。 执行顺序总结 首先执行 useMemo 和 useCallback：在组件渲染函数中计算值和函数引用。 随后进行 DOM 更新：将渲染结果应用到 DOM。 最后执行 useEffect 中的副作用函数：处理副作用，与数据获取、订阅等相关。 这种执行顺序确保了在调用 effect 时，组件已经完成了渲染，并且可以安全地使用渲染过程中创建的值和函数引用。希望这能帮助你理解这三个钩子的执行顺序！useEffect 在 React 的执行顺序中被设计为在组件渲染后执行，这样的设计有几个重要原因： 1. 渲染结果的可用性 useEffect 依赖于组件渲染后的状态和 DOM 节点。如果在渲染过程之前执行 useEffect，那么它可能会尝试访问未更新的状态或未渲染的 DOM 结构，这会导致不可预测的行为和错误。因此，React 选择在渲染完成后再执行 useEffect，以确保所有的渲染结果和状态都是最新的。 2. 性能优化 在组件渲染期间，React 会进行虚拟 DOM 的计算和对比，以决定如何高效地更新实际 DOM。如果将副作用放在渲染过程中，可能会导致不必要的渲染延迟和性能损失。通过将副作用放在渲染的下一步，React 可以优化这些操作，从而提升性能。 3. 避免副作用影响渲染 副作用通常涉及异步操作（如数据获取、订阅等），这些操作可能需要时间才能完成。如果在渲染期间执行这些操作，会导致组件的显示延迟或不一致。将副作用放在渲染后，可以确保用户看到的是稳定的 UI，而不会因为运行副作用而造成闪烁或不一致的体验。 总结 通过在渲染完成后才执行 useEffect，React 能够确保： 访问的是最新的状态和 DOM； 不影响渲染性能和用户体验； 副作用可以安全地处理和清理。 这种设计使得 React 的组件能够更加高效和稳定。","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"谐云科技","slug":"谐云科技","date":"2024-10-25T01:56:27.000Z","updated":"2024-10-25T02:02:48.088Z","comments":true,"path":"2024/10/25/谐云科技/","permalink":"https://0922wx.github.io/2024/10/25/%E8%B0%90%E4%BA%91%E7%A7%91%E6%8A%80/","excerpt":"","text":"不像是要招人的样子捏 HTTP1.0和2.0 项目是练手的还是投入使用了 react双向绑定 react数据缓存？（不知道什么东西） JS和TS有什么区别 讲一下事件循环 怎么看待互联网行业 怎么看加班 反问： 实习生会先培训再投入研发 主要是react 昨夜想了很久，哪个路口哪有~","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"脑虎科技之马踏棋盘","slug":"脑虎科技之马踏棋盘","date":"2024-10-23T09:52:10.000Z","updated":"2024-10-23T11:54:49.538Z","comments":true,"path":"2024/10/23/脑虎科技之马踏棋盘/","permalink":"https://0922wx.github.io/2024/10/23/%E8%84%91%E8%99%8E%E7%A7%91%E6%8A%80%E4%B9%8B%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98/","excerpt":"","text":"这是一个著名的问题。在 8×8 的国际象棋棋盘上用一个马按照马步跳遍整个棋盘，要求每个格子都只跳到一次，最后回到出发点。 第一问 你的任务是实现一个网页来展示马踏棋盘的整个交互过程。需求描述如 下： 需求a.页面上有一个输入框 “start point”，用户可以输入马的起始位置。起始位置是用逗号隔开的 2 个整数。例如用户输入 4,4，下面右图的起始位置 1 就 是坐标(4,4) 需求b. 实现一个拖动条，用户拖动这个拖动条，可以看到马当前移动的路径。 例如用户拖动到 40，那么下面的图就要展示出从第 1 到第 40 步移动的路径。 需求c. 实现两个个按钮，“line”用于显示马移动的路径，“numbers”用于 显示移动的步数。我这里图片显示是 2 个棋盘，你实际实现的时候，用户只应该 看到一个棋盘，用户点击 line 和 numbers 按钮的时候，棋盘显示效果会发生切换。 第二问 马踏棋盘并不是只是在国际象棋棋盘上才成立，其他尺寸的棋盘也一样 具有这样的结论。传统的马踏棋盘需要马最终回到起点，第二和第三问这里可以 稍微弱化我们的要求，只要求走完整个棋盘的格子，不要求回到起点。 需求 d：在保留前面功能的前提下，增加一个输入框，名称叫“board size”， 用于输入棋盘的大小。起始位置是用逗号隔开的 2 个整数。例如输入 (3,10)，得 到的结果是这样的 例如输入 (25,25)，得到的结果是这样的 第三问 马踏棋盘并不是只是在矩形的棋盘上才成立，其他不规则图形也有可能 具有这样的结论。 需求 e：在保留需求 a，b，c 的前提下，增加一个用户自定义棋盘按钮“user defined board”，用户点击此按钮之后可以从自己的电脑上传一个自己定义的 棋盘文件，这个文件是用 json 或者 yaml 描述的。然后得到不规则图形的马踏 棋盘交互效果，如下图所示。你的代码注释里要讲清楚如何描述不规则棋盘 okok,一个个来 第一问 先实现一下8x8的棋盘再说 1234567891011121314151617181920import &quot;./App.scss&quot;;function renderSquare() &#123; const squares = []; for (let i = 0; i &lt; 8; i++) &#123; for (let j = 0; j &lt; 8; j++) &#123; const squareClass = (i + j) % 2 === 0 ? &quot;square&quot; : &quot;square-black&quot;; squares.push(&lt;button key=&#123;`$&#123;i&#125;-$&#123;j&#125;`&#125; className=&#123;squareClass&#125;&gt;&lt;/button&gt;); &#125; &#125; return squares;&#125;function App() &#123; return ( &lt;div className=&quot;container&quot;&gt;&#123;renderSquare()&#125;&lt;/div&gt; );&#125;export default App; 123456789101112131415161718192021222324252627282930.container &#123; position: absolute; top: 0; left: 0; transform: translate(50%, 20%); height: 600px; width: 600px; border: 1px solid black; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); .square &#123; background-color: white; &amp;:hover &#123; background-color: #b8b4b4; cursor: pointer; &#125; &amp;-black &#123; background-color: black; &amp;:hover &#123; background-color: #333; cursor: pointer; &#125; &#125; &#125;&#125; 然后加上文本框和马 12345678910111213141516171819202122232425262728import &quot;./App.scss&quot;;import Icon from &quot;./assets/horse.svg&quot;;function renderSquare() &#123; const squares = []; for (let i = 0; i &lt; 8; i++) &#123; for (let j = 0; j &lt; 8; j++) &#123; const squareClass = (i + j) % 2 === 0 ? &quot;square&quot; : &quot;square-black&quot;; squares.push(&lt;div key=&#123;`$&#123;i&#125;-$&#123;j&#125;`&#125; className=&#123;squareClass&#125;&gt;&lt;/div&gt;); &#125; &#125; return squares;&#125;function App() &#123; return ( &lt;&gt; &lt;div className=&quot;container&quot;&gt;&#123;renderSquare()&#125;&lt;/div&gt; &lt;img src=&#123;Icon&#125; alt=&quot;horse&quot; /&gt; &lt;div className=&quot;searchbox&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;button&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;/&gt; );&#125;export default App; 12345678910111213141516171819202122232425262728293031323334353637383940414243.container &#123; position: absolute; top: 0; left: 0; transform: translate(50%, 20%); height: 600px; width: 600px; border: 1px solid black; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); .square &#123; background-color: white; border: 1px solid black; &amp;:hover &#123; background-color: #b8b4b4; cursor: pointer; &#125; &amp;-black &#123; background-color: black; &amp;:hover &#123; background-color: #333; cursor: pointer; &#125; &#125; &#125;&#125;.searchbox &#123; position: absolute; top: 70%; left: 28%; input &#123; width: 200px; height: 20px; font-size: 18px; &#125; button &#123; vertical-align: top; height: 26px; &#125;&#125; 那么下一个问题:获取文本框的输入并区分逗号? const values = inputValue.split(&quot;,&quot;).map(Number); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import &quot;./App.scss&quot;;import Icon from &quot;./assets/horse.svg&quot;;import &#123; ChangeEvent, useState &#125; from &quot;react&quot;;// 渲染8x8的棋盘function renderSquare(startPosition: [number, number] | null) &#123; const squares = []; for (let i = 0; i &lt; 8; i++) &#123; for (let j = 0; j &lt; 8; j++) &#123; const squareClass = (i + j) % 2 === 0 ? &quot;square&quot; : &quot;square-black&quot;; squares.push( &lt;div key=&#123;`$&#123;i&#125;-$&#123;j&#125;`&#125; className=&#123;squareClass&#125;&gt; &#123;startPosition &amp;&amp; startPosition[0] === i &amp;&amp; startPosition[1] === j &amp;&amp; ( &lt;img src=&#123;Icon&#125; alt=&quot;horse&quot; style=&#123;&#123;position:&quot;absolute&quot;&#125;&#125; /&gt; )&#125; &lt;/div&gt; ); &#125; &#125; return squares;&#125;function App() &#123; const [inputValue, setInputValue] = useState(&quot;&quot;); const [startPosition, setStartPosition] = useState&lt;[number, number] | null&gt;(null); const handleClick = () =&gt; &#123; const values = inputValue.split(&#x27;,&#x27;).map(Number); if (values.length === 2 &amp;&amp; values.every(n =&gt; !isNaN(n) &amp;&amp; n &gt;= 0 &amp;&amp; n &lt; 8)) &#123; setStartPosition([values[0], values[1]]); &#125; else &#123; alert(&quot;请输入有效的起始位置,格式为:x,y,且 x 和 y 在 0 到 7 之间.&quot;); &#125; &#125; const handleChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123; setInputValue(event.target.value); &#125;; return ( &lt;&gt; &lt;div className=&quot;container&quot;&gt;&#123;renderSquare(startPosition)&#125;&lt;/div&gt; &lt;div className=&quot;searchbox&quot;&gt; &lt;input type=&quot;text&quot; value=&#123;inputValue&#125; onChange=&#123;handleChange&#125; /&gt; &lt;button type=&quot;submit&quot; onClick=&#123;handleClick&#125;&gt; 确定 &lt;/button&gt; &lt;/div&gt; &lt;/&gt; );&#125;export default App;","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"全字母短句","slug":"全字母短句","date":"2024-10-21T12:39:22.000Z","updated":"2024-10-21T12:47:06.528Z","comments":true,"path":"2024/10/21/全字母短句/","permalink":"https://0922wx.github.io/2024/10/21/%E5%85%A8%E5%AD%97%E6%AF%8D%E7%9F%AD%E5%8F%A5/","excerpt":"","text":"Pangrams | HackerRank 全字母短句中每个字母都出现至少一次 给定一个句子s , 告诉 Roy 这个句子是不是一个全字母短句。 最开始想遍历然后用正则求，后来发现是整个句子的字母不重复 1234567891011function pangrams(s: string): string &#123; // Write your code here const newStr = s.toLowerCase().replace(/\\s+/g, &#x27;&#x27;); const uniqueLetters = new Set(newStr); if (uniqueLetters.size &gt;= 26) &#123; return &#x27;pangram&#x27;; &#125; else &#123; return &#x27;not pangram&#x27;; &#125;&#125; 利用set做 将输入字符串转换为小写，并移除所有空格 检查去重后字母的数量是否至少为 26 replace(/\\s+/g, '')正则，\\s表示空白字符，+是前面的元素，合起来就是将匹配一个或多个连续的空白字符，将匹配到的空白换成空字符 uniqueLetters.size &gt;= 26是何意啊 set.size返回元素数量","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"理解依赖注入","slug":"理解依赖注入","date":"2024-10-20T06:11:26.000Z","updated":"2024-10-20T07:14:20.284Z","comments":true,"path":"2024/10/20/理解依赖注入/","permalink":"https://0922wx.github.io/2024/10/20/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"","text":"什么是依赖关系 你有一个用户类，一个帖子类，一个页面类 每当创建帖子或者页面时，都需要用户类（因为要检查创建页面或者帖子的用户是否在数据库中，并关联二者） 那么在创建帖子或者页面时，你就需要用户类这个依赖项 哦豁，那理论上每次创建帖子或者页面的时候都要随时新建一个用户类了 听上去一下子就变得恶心起来了，因为都让你耦合完了，性能什么的也不用考虑，因为卡爆了 1234567891011121314151617181920class User &#123; constructor() &#123; console.log(&#x27;User was instantiated&#x27;) &#125; public name = &#x27;wx&#x27;;&#125;class Post &#123; constructor(private user = new User()) &#123; console.log(&#x27;Post was instantiated&#x27;) &#125;&#125;class Page &#123; constructor(private user = new User()) &#123; console.log(&#x27;Page was instantiated&#x27;) &#125;&#125;//client codeconst post = new Post()const page = new Page() 1234[LOG]: &quot;User was instantiated&quot; [LOG]: &quot;Post was instantiated&quot; [LOG]: &quot;User was instantiated&quot; [LOG]: &quot;Page was instantiated&quot; 不过我们有无需注入的依赖关系方法，也就是依赖注入 依赖注入 对的，我生来就是干这个的 不用new创建实例，一手反转控制，只要创建一个实例就可以掌控所有东西，ts可以这么干 12345678910111213141516171819202122232425262728class User &#123; constructor() &#123; console.log(&#x27;User was instantiated&#x27;) &#125; public name = &#x27;wx&#x27;;&#125;class Post &#123; constructor(private user :User ) &#123; console.log(&#x27;Post was instantiated&#x27;) console.log(this.user) &#125;&#125;class Page &#123; constructor(private user :User) &#123; console.log(&#x27;Page was instantiated&#x27;) &#125;&#125;//nestjsconst user = new User()//client codeconst post = new Post(user)const page = new Page(user) 123456[LOG]: &quot;User was instantiated&quot; [LOG]: &quot;Post was instantiated&quot; [LOG]: User: &#123; &quot;name&quot;: &quot;wx&quot;&#125; [LOG]: &quot;Page was instantiated&quot; 这下只实例一次了 nest里的依赖注入 好就好在解耦又方便测试，还有可重用性 那么模块是如何封装这些不同的类，注入依赖呢？ 首先理解一件事在nest中，Module是最高指挥官，他将所有提供的程序封装其中（service controller customer class） 这意味着Module是决定某项特定服务是否导出或者被别人使用。因此，在一个特定模块内写入的所有内容都将保留在一个模块内，由你决定是否共享。比如 classDiagram User Module","categories":[{"name":"后端","slug":"后端","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"nest","slug":"后端/nest","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/nest/"}],"tags":[]},{"title":"一些用得到的nest插件","slug":"一些用得到的nest插件","date":"2024-10-20T05:58:00.000Z","updated":"2024-10-20T07:47:17.438Z","comments":true,"path":"2024/10/20/一些用得到的nest插件/","permalink":"https://0922wx.github.io/2024/10/20/%E4%B8%80%E4%BA%9B%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84nest%E6%8F%92%E4%BB%B6/","excerpt":"","text":"class-transformer 在DTO中转化类型，毕竟url里的都是字符串，总得改一下类型，不然报错 class-validator 一些判断条件,IsInt()什么的 @nestjs/mapped-types ts工具类的效果 比如 12345import &#123;PartialType&#125; from &#x27;@nestjs/mapped-types&#x27;import &#123;CreateUserDto&#125; from &#x27;./create-user.dto&#x27;export class PatchUserDto extend PartialType(CreateUserDto)&#123;&#125; 全部可选 @nestjs/swagger 集成swagger D:\\BaiduNetdiskDownload\\NestJS Masterclass - From Beginner To Advanced\\5. Documenting Code \\ 3. Enabling Swagger in NestJS nestjs/config 环境变量相关","categories":[{"name":"后端","slug":"后端","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"nest","slug":"后端/nest","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/nest/"}],"tags":[]},{"title":"花式数据请求","slug":"花式数据请求","date":"2024-10-20T04:15:11.000Z","updated":"2024-10-20T04:52:56.867Z","comments":true,"path":"2024/10/20/花式数据请求/","permalink":"https://0922wx.github.io/2024/10/20/%E8%8A%B1%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/","excerpt":"","text":"如何获取url中的参数呢 比如get用户id 123456789101112import &#123; Controller, Get &#125; from &#x27;@nestjs/common&#x27;;import &#123; UserService &#125; from &#x27;./user.service&#x27;;@Controller(&#x27;user&#x27;)export class UserController &#123; constructor(private readonly userService: UserService) &#123;&#125; @Get(&#x27;/:id&#x27;) getUsers() &#123; return &quot;GetUsers&quot; &#125;&#125; 在nest中，可以用param装饰器获取，这种参数总是以斜线加冒号的形式给出 这么用 12345678910111213import &#123; Controller, Get,Param&#125; from &#x27;@nestjs/common&#x27;;import &#123; UserService &#125; from &#x27;./user.service&#x27;;@Controller(&#x27;user&#x27;)export class UserController &#123; constructor(private readonly userService: UserService) &#123;&#125; @Get(&#x27;/:id&#x27;) getUsers(@Param() params: any) &#123; console.log(params)//获取参数 return &quot;GetUsers&quot; &#125;&#125; 多写个参数会怎么样？不会怎么样，像写多少写多少 发送/users/123456/optional 12345@Get(&#x27;/:id:optional?&#x27;) getUsers(@Param() params: any) &#123; console.log(params) //&#123;id:&#x27;123456&#x27;,optional:&#x27;optional&#x27;&#125; return &quot;GetUsers&quot; &#125; 发送/users/123456 1&#123;id:&#x27;123456&#x27;,optional:undfiend&#125; 这就是如何获取参数。 除了获取，自然也能查询 查询参数 使用Query() 通过 url 中 ？后面的用 &amp; 分隔的字符串传递数据。 1http://wx.com/person?name=wx&amp;age=23 name和age就是其传递的数据 发送users/123456?limit=10&amp;offset=20 1&#123;limit:&#x27;10&#x27;,offset:&#x27;20&#x27;&#125; 最终提供的是js对象 那怎么发请求主体呢 请求参数 先写个请求主体 12345&#123; &#x27;name&#x27;:&#x27;wx&#x27;, &#x27;password&#x27;:&#x27;123456&#x27;, &#x27;email&#x27;:&#x27;wx.com&#x27;&#125; 那这种要怎么获取呢 Body() 12345@Post()createUsers(@Body() request:any)&#123; console.log(request) return &#x27;you sen a post request&#x27;&#125; 打印出 12345&#123; &#x27;name&#x27;:&#x27;wx&#x27;, &#x27;password&#x27;:&#x27;123456&#x27;, &#x27;email&#x27;:&#x27;wx.com&#x27;&#125; nest底层使用了express，所以也可以这么玩 12import &#123;Req&#125; from &#x27;@nestjs/common&#x27;import &#123;Request&#125; from &#x27;express&#x27; 12345@Post()createUsers(@Req() request:Request)&#123; console.log(request) return &#x27;you sen a post request&#x27;&#125; 这下子会打印一个很长的的对象，整个请求对象 这样也只是能玩罢了，不建议用 那么怎么缩小范围，获取特定的查询参数，参数或者特定键值对呢 比如 123456@Get(&#x27;/:id:optional?&#x27;)getUsers(@Param() params: any, @Query() query: any) &#123; console.log(params); console.log(query); return &#x27;GetUsers&#x27;;&#125; 我只想获取id，不想获取可选的东西呢 在括号里加点东西就行了 123456@Get(&#x27;/:id:optional?&#x27;)getUsers(@Param(&#x27;id&#x27;) id: any, @Query() query: any) &#123; console.log(id); console.log(query); return &#x27;GetUsers&#x27;;&#125; 如果想获取请求头，有Headers() 还有Ip()","categories":[{"name":"后端","slug":"后端","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"nest","slug":"后端/nest","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/nest/"}],"tags":[]},{"title":"Permuting Two Arrays某种排列","slug":"Permuting-Two-Arrays某种排列","date":"2024-10-18T13:09:10.000Z","updated":"2024-10-18T13:14:54.887Z","comments":true,"path":"2024/10/18/Permuting-Two-Arrays某种排列/","permalink":"https://0922wx.github.io/2024/10/18/Permuting-Two-Arrays%E6%9F%90%E7%A7%8D%E6%8E%92%E5%88%97/","excerpt":"","text":"123 Permuting Two Arrays | HackerRank 将有A,B和K组成的q查询。对于每个查询，如果存在满足关系的排列A,B，则返回YES,否则NO 比如： A = [0,1] B = [0,2] k = 1 1+0 &gt;= 1 0+2 &gt;= 1 RETURN YES 一开始只想着一个一个对过去就好，没想到要排序 12345678function twoArrays(k: number, A: number[], B: number[]): string &#123; for (let i = 0; i &lt; A.length; i++) &#123; if (A[i] + B[i] &lt; k) &#123; return &#x27;No&#x27;; &#125; &#125; return &#x27;Yes&#x27;;&#125; 修改后 123456789101112function twoArrays(k: number, A: number[], B: number[]): string &#123; // Write your code here A.sort((a, b) =&gt; a - b); B.sort((a, b) =&gt; b - a); for (let i = 0; i &lt; A.length; i++) &#123; if (A[i] + B[i] &lt; k) &#123; return &#x27;NO&#x27;; &#125; &#125; return &#x27;YES&#x27;;&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第三周","slug":"HackerRank三个月挑战/第三周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%89%E5%91%A8/"}],"tags":[]},{"title":"nest导入模块","slug":"nest导入模块","date":"2024-10-18T11:07:43.000Z","updated":"2024-10-20T07:16:24.396Z","comments":true,"path":"2024/10/18/nest导入模块/","permalink":"https://0922wx.github.io/2024/10/18/nest%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97/","excerpt":"","text":"如果你想要在Amodule里使用Bmodule里的服务那么可以选择： 如果模块外导入你想要在Amodule里使用Bmodule里的服务那么可以选择： 在Bmodule里写入exports:[BService] 在Amodule里写入import:[Bmodule] 没错，第二次是导入module，而不是service 这是最容易看错的 导入之后，有两种方式注入依赖 1.属性注入依赖 1234567891011@Injectable()export class OrderService &#123;//依赖注入之属性注入共享的服务 @Inject(BService) private bService:BService; getOrderDesc():string&#123; const name = this.userService.getUserName(); return `Order for $&#123;name&#125;`; &#125;&#125; 2.构造函数注入 12345678@Injectable()export class OrderService &#123; constructor(private userService:UserService)&#123;&#125; getOrderDesc():string&#123; const name = this.userService.getUserName(); return `Order for $&#123;name&#125;`; &#125;&#125; 全局模块 用@Global装饰器声明就完事了（在module声明） 1234567891011import &#123; Global, Module &#125; from &#x27;@nestjs/common&#x27;;import &#123; UserService &#125; from &#x27;./user.service&#x27;;import &#123; UserController &#125; from &#x27;./user.controller&#x27;;@Global()@Module(&#123; controllers: [UserController], providers: [UserService], exports: [UserService],&#125;)export class UserModule &#123;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"nest","slug":"后端/nest","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/nest/"}],"tags":[]},{"title":"记一下vs插件","slug":"记一下vs插件","date":"2024-10-17T14:46:51.000Z","updated":"2024-10-17T14:55:50.119Z","comments":true,"path":"2024/10/17/记一下vs插件/","permalink":"https://0922wx.github.io/2024/10/17/%E8%AE%B0%E4%B8%80%E4%B8%8Bvs%E6%8F%92%E4%BB%B6/","excerpt":"","text":"12 别名路径跳转 any-rule Bearded Theme CSS Modules Error Lens es6-string-html ES7+ React/Redux/React-Native snippets ESLint Fitten Code: Faster and Better AI Assistant GitLens — Git supercharged HTML CSS Support JS JSX Snippets json Less IntelliSense Live Preview Live Server Move TS and JS - Move TypeScript/JS files and update relative importsv1. Native Debug open in browser Path Autocomplete Path Intellisense Prettier - Code formatter Prisma px to rem &amp; rpx &amp; vw (cssrem) React React Redux Toolkit RTK Query Snippets Tailwind CSS IntelliSense Thunder Client Time Master TypeScript Importer vscode-icons Three.JS Snippets","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vscode","slug":"前端/vscode","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/vscode/"}],"tags":[]},{"title":"10-16折腾一下自动化部署","slug":"10-16折腾一下自动化部署","date":"2024-10-16T07:43:10.000Z","updated":"2024-10-16T08:08:32.686Z","comments":true,"path":"2024/10/16/10-16折腾一下自动化部署/","permalink":"https://0922wx.github.io/2024/10/16/10-16%E6%8A%98%E8%85%BE%E4%B8%80%E4%B8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","excerpt":"","text":"没错，目前每次发表都需要手动编译再推送，还有一个缺点是hexo源码本身没有云端备份（虽然不知道到底有什么后果）。 听说引入Github Action工作流后就可以交给Github自动完成了 点开仓库的settings -&gt; Pages,找到Build and deployment下Source，换成Github Actions。提示使用jekyll，点击jekyll的Configure，自动生成他的actions，然后点击右上角commit changes，直接点击提交，就创建完毕了。 弄完了，那到底有什么区别呢 我不知道","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"理灵文化","slug":"理灵文化","date":"2024-10-14T08:36:42.000Z","updated":"2024-10-16T07:34:08.318Z","comments":true,"path":"2024/10/14/理灵文化/","permalink":"https://0922wx.github.io/2024/10/14/%E7%90%86%E7%81%B5%E6%96%87%E5%8C%96/","excerpt":"","text":"汗流浃背 汗流浃背 甚至不小心鸽了一个多小时 1.介绍js数组方法，数组遍历方法的相关区别 2.react常用hook 3.css居中 4.ts工具类型 5.== 和 === 区别 6.filter 和 find 区别 7.语义化标签用处，怎么用 8.interface和type区别 9.学习路线，怎么学习的，看谁的博客 10.display:none和opacity: 0的区别 11.严格模式会渲染两次吗 项目相关 (失忆完了) 五天内 TS工具类型 一种在类型别名的基础上，基于泛型去动态创建新类型 Partial：将所有类型设置为可选Partial&lt;A&gt; Required:所有属性必选 readonly：将属性标记为只读 Record:声明属性名还未确定的接口类型 Record&lt;K,T&gt;构造具有给定类型T的一组属性K的类型。在将一个类型的属性映射到另一个类型的属性时，Record非常方便。 12345678type UserProps = &#x27;name&#x27; | &#x27;job&#x27; | &#x27;email&#x27;;// 等价于你一个个实现这些属性了type User = Record&lt;UserProps, string&gt;;const user: User = &#123; name: &#x27;John Doe&#x27;, job: &#x27;fe-developer&#x27;, email: &#x27;john.doe@example.com&#x27;&#125;; Pick:接收一个对象类型，以及一个字面量类型组成的联合类型，这个联合类型只能是由对象类型的属性名组成的。它会对这个对象类型进行裁剪，只保留你传入的属性名组成的部分 12345678type User = &#123; name: string; age: number; email: string; phone: string;&#125;;// 只提取其中的 name 与 age 信息type UserBasicInfo = Pick&lt;User, &#x27;name&#x27; | &#x27;age&#x27;&gt;; Omit:就是 Pick 类型的另一面，它的入参和 Pick 类型一致，但效果却是相反的——它会移除传入的属性名的部分，只保留剩下的部分作为新的对象类型 123456789type User = &#123; name: string; age: number; email: string; phone: string;&#125;;// 只移除 phone 属性type UserWithoutPhone = Omit&lt;User, &#x27;phone&#x27;&gt;; Exclude 和Extract:差集和交集 12345type UserProps = &#x27;name&#x27; | &#x27;age&#x27; | &#x27;email&#x27; | &#x27;phone&#x27; | &#x27;address&#x27;;type RequiredUserProps = &#x27;name&#x27; | &#x27;email&#x27;;// OptionalUserProps = UserProps - RequiredUserPropstype OptionalUserProps = Exclude&lt;UserProps, RequiredUserProps&gt;;const optionalUserProps: OptionalUserProps = &#x27;age&#x27;; // &#x27;age&#x27; | &#x27;phone&#x27; | &#x27;address&#x27;; Extract 1234type UserProps = &#x27;name&#x27; | &#x27;age&#x27; | &#x27;email&#x27; | &#x27;phone&#x27; | &#x27;address&#x27;;type RequiredUserProps = &#x27;name&#x27; | &#x27;email&#x27;;type RequiredUserPropsOnly = Extract&lt;UserProps, RequiredUserProps&gt;;const requiredUserPropsOnly: RequiredUserPropsOnly = &#x27;name&#x27;; // &#x27;name&#x27; | &#x27;email&#x27;; display none 和 opacity 0二者的区别 display:none 完全隐藏HTML元素并从页面布局移除他，不会显示在页面上，也不会占据空间，不会响应任何交互事件 opacity:0 完全透明，但元素仍然存在于页面布局中，并保持原始大小和位置，但对用户来说不可见，仍然可以接收交互事件，包括键盘和屏幕阅读器事件。 无障碍性考虑 display:none： 可见性：display: none 隐藏了元素，对于所有用户，包括屏幕阅读器用户，它都是不可见的。 交互性：由于元素被隐藏，因此不会响应键盘或屏幕阅读器事件。这可能导致对于视力障碍者而言，无法访问其中的内容或功能。 语义：如果使用 display: none 隐藏了某些重要内容，屏幕阅读器无法访问这些内容，因此会导致可访问性问题。 opacity: 0: 可见性：opacity: 0 使元素不可见，但仍然存在于页面布局中，因此对于视力障碍者来说，它是可见的（虽然不可见，但占据页面空间）。 交互性：元素保持交互性，因此可以响应键盘和屏幕阅读器事件，使其内容和功能可访问。 语义：使用 opacity: 0 可以确保屏幕阅读器能够访问元素的内容，以提供更好的可访问性。 额外 display: none visibility: hidden opacity: 0 是否占有空间 × √ √ 是否可以进行DOM事件监听 × × √ 是否可以点击 × × √ 是否可以被子元素继承 × √ √ 子元素能否通过改变属性值来改变继承自父亲的隐藏状态 × √ × visibility: hidden 是什么？ display: none： 从这个世界消失了, 不存在了； opacity: 0： 视觉上隐身了, 看不见, 可以触摸得到； visibility: hidden： 视觉和物理上都隐身了, 看不见也摸不到, 但是存在的。 来源：opacity: 0、visibility: hidden、display: none 优劣和适用场景，以及隐藏元素的几种方法 - 掘金 (juejin.cn)","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"面试题","slug":"面试题","date":"2024-10-13T06:47:49.000Z","updated":"2024-10-13T09:38:15.467Z","comments":true,"path":"2024/10/13/面试题/","permalink":"https://0922wx.github.io/2024/10/13/%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"script标签里的async和defer有什么区别？ 没有async和defer时： 浏览器立即加载并执行指定的脚本 有async： 加载和渲染后面元素的过程将和script的加载和执行并行进行(异) 有defer: 加载和渲染后面元素的过程将和script的加载并行进行，要等所有元素解析完成之后才会执行(异) 创造的时间节点，defer比async早，defer保证脚本顺序，async不会，谁先下载好就加载谁 setTimeout最小执行时间 setTimeout：4ms setInterval：10ms，小于10ms就会被调整到10ms 为什么是这两个数字？ ——&gt; htlm5就是这么规定的 DOM树和渲染树区别 DOM树和HTML标签一一对应，包括head和隐藏元素 渲染树是不包含head和隐藏元素 git解决冲突 比如： 两个分支修改同一个文件 两个分支修改同一个文件的名字 解决： 当前分支上直接修改代码 add commit 本地当前分支上修改冲突 add commit push redux核心原理 核心组成三部分： Store Action Reducer：一个函数，接收两个参数，action和当前state 整个工作流程，数据流严格单向，只能通过dispatch action的方式触发数据状态的修改 Action进入对于Reducer进行处理最终得到新的状态State，再进一步触发Vaiew的数据更新 HashRouter和BrowserRouter区别 HashRouter： 基于hash模式，跳转原理是使用了location.hash、location.replace在域名后，先拼接 /#，再拼接路径，也就是利用锚点，实现路由的跳转。如：http://www.dzm.com/#/xx BrowserRouter： 基于history模式，原理是了 HTML5 为浏览器全局的 history 对象新增了两个 API，包括 history.pushState、history.replaceState","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试题","slug":"前端/面试题","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"10-13","slug":"10-13","date":"2024-10-13T03:08:47.000Z","updated":"2024-10-25T15:30:33.241Z","comments":true,"path":"2024/10/13/10-13/","permalink":"https://0922wx.github.io/2024/10/13/10-13/","excerpt":"","text":"北海牧场浓醇凝酪 豪赤","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"FirstofArray","slug":"FirstofArray","date":"2024-10-11T14:30:02.000Z","updated":"2024-10-11T14:34:40.827Z","comments":true,"path":"2024/10/11/FirstofArray/","permalink":"https://0922wx.github.io/2024/10/11/FirstofArray/","excerpt":"","text":"实现一个First&lt;T&gt;泛型，它接受一个数组T并返回它的第一个元素的类型。 1234type arr1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]type arr2 = [3, 2, 1]type head1 = First&lt;arr1&gt; // 应推导出 &#x27;a&#x27;type head2 = First&lt;arr2&gt; // 应推导出 3 12345678910111213141516171819// ============= Test Cases =============import type &#123; Equal, Expect &#125; from &#x27;./test-utils&#x27;type cases = [ Expect&lt;Equal&lt;First&lt;[3, 2, 1]&gt;, 3&gt;&gt;, Expect&lt;Equal&lt;First&lt;[() =&gt; 123, &#123; a: string &#125;]&gt;, () =&gt; 123&gt;&gt;, Expect&lt;Equal&lt;First&lt;[]&gt;, never&gt;&gt;, Expect&lt;Equal&lt;First&lt;[undefined]&gt;, undefined&gt;&gt;,]type errors = [ // @ts-expect-error First&lt;&#x27;notArray&#x27;&gt;, // @ts-expect-error First&lt;&#123; 0: &#x27;arrayLike&#x27; &#125;&gt;,]// ============= Your Code Here =============type First&lt;T extends any[]&gt; = what can i say? 毫无头绪捏 type First&lt;T extends any[]&gt; = T extends [infer F, ...any[]] ? F : never; 通过条件类型提取数组的第一个元素 F。[infer F, ...any[]] 表示一个数组，F 是第一个元素，...any[] 表示剩余的元素可以是任意类型。 我怎么感觉好像没看过这种东西 什么遍历 infer，完全找不到地方看","categories":[{"name":"TS类型体操","slug":"TS类型体操","permalink":"https://0922wx.github.io/categories/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"},{"name":"简单题","slug":"TS类型体操/简单题","permalink":"https://0922wx.github.io/categories/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/%E7%AE%80%E5%8D%95%E9%A2%98/"}],"tags":[]},{"title":"Object.key,value和entries","slug":"Object-key-value和entries","date":"2024-10-11T12:57:37.000Z","updated":"2024-10-11T13:08:28.530Z","comments":true,"path":"2024/10/11/Object-key-value和entries/","permalink":"https://0922wx.github.io/2024/10/11/Object-key-value%E5%92%8Centries/","excerpt":"","text":"key和value，键值对罢了 123console.log(Object.keys(&#123;name:&quot;tom&quot;,age:11&#125;); // [&quot;name&quot;,&quot;age&quot;]console.log(Object.values(&#123;name:&quot;tom&quot;,age:11&#125;) // [&#x27;tom&#x27;,11] 主要是记录一下entries() 1console.log(Object.entries(&#123;name:&quot;tom&quot;,age:11&#125;)//[Array(2),Arrar(2)] 我去，二维数组 1console.log(Object.entries([1,2,3])//[Array(2),Arrar(2),Arrar(2)] 手工返回键值对组成的数组，第一个元素是属性的键（始终是字符串），第二个元素是属性值。 那么绝配map了 123const obj = &#123; foo: &quot;bar&quot;, baz: 42 &#125;;const map = new Map(Object.entries(obj));console.log(map); // 输出: Map(2) &#123;&quot;foo&quot; =&gt; &quot;bar&quot;, &quot;baz&quot; =&gt; 42&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"}],"tags":[]},{"title":"神秘小厂","slug":"神秘小厂","date":"2024-10-10T11:51:17.000Z","updated":"2024-10-10T12:01:25.695Z","comments":true,"path":"2024/10/10/神秘小厂/","permalink":"https://0922wx.github.io/2024/10/10/%E7%A5%9E%E7%A7%98%E5%B0%8F%E5%8E%82/","excerpt":"","text":"面面相觑 1.vue的生命周期(没用过vue) 2.小程序做过吗(没有) 3.css2和css3有什么区别 4.怎么水平居中 5.es6新增了什么 6.==和===的区别 7.react怎么父传子 8.聊天室用了什么技术聊天(websocket) 反问: 主要用vue，原生小程序开发","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"ThreeJs一些概念","slug":"ThreeJs","date":"2024-10-09T10:40:57.000Z","updated":"2024-10-13T13:28:34.072Z","comments":true,"path":"2024/10/09/ThreeJs/","permalink":"https://0922wx.github.io/2024/10/09/ThreeJs/","excerpt":"","text":"三要素 场景 Scene 容器 相机 Camera 观察 渲染器 Render 组合 起步 随便找一个文件夹.yarn init,然后在设置里面写: 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot; &#125;, 然后yarn add -D vite yarn add -D three OK 始于此 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;module&quot;&gt; import * as THREE from &quot;three&quot; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建场景-&gt;创建相机-&gt;创建渲染器 12345678910&lt;script type=&quot;module&quot;&gt; import * as THREE from &quot;three&quot;; const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera( 45,window.innerWidth/window.innerHeight, 0.1, 1000 ) const renderer = new THREE.WebGLRenderer();&lt;/script&gt; 东西都有了，那要怎么才能看到呢？ document.body.appendChild(renderer.domElement); 获取camera元素 1234567891011121314151617181920212223242526272829 const scene = new THREE.Scene(); //创建相机 const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000) //设置相机位置 camera.position.z = 3 camera.position.y = 2 camera.lookAt(0, 0, 0) //创建渲染器 const renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); const cube = new THREE.Mesh( new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial() ) scene.add(cube)function animate()&#123; requestAnimationFrame(animate); cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render(scene, camera);&#125;animate();","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"ThreeJs","slug":"前端/ThreeJs","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/ThreeJs/"},{"name":"事前准备","slug":"前端/ThreeJs/事前准备","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/ThreeJs/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"}],"tags":[]},{"title":"自留按钮动画","slug":"自留按钮动画","date":"2024-10-09T07:58:15.000Z","updated":"2024-10-22T07:21:29.354Z","comments":true,"path":"2024/10/09/自留按钮动画/","permalink":"https://0922wx.github.io/2024/10/09/%E8%87%AA%E7%95%99%E6%8C%89%E9%92%AE%E5%8A%A8%E7%94%BB/","excerpt":"","text":"十字形劈开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849.btn &#123; margin: 80px; width: 400px; height: 80px; position: relative; font-size: 4rem; background-color: #f2f2f2; color: black; z-index: 1; transition: 1s;&#125;.btn::before &#123; content: &quot;&quot;; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #262626; transform: rotateX(90deg); transition: 1s; z-index: -1;&#125;.btn:hover::before &#123; transform: rotateX(0deg);&#125;.btn::after &#123; content: &quot;&quot;; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #262626; transform: rotateY(90deg); transition: 1s; z-index: -1;&#125;.btn:hover::after &#123; transform: rotateY(0deg);&#125;.btn:hover &#123; color: #fff;&#125; 十字形黑到白,原理是通过旋转x和y轴得到 自上而下倒塌 12345678910111213141516171819202122232425.roate &#123; margin: 5px; width: 400px; height: 50px; margin-top: 200px; position: relative; overflow: hidden; background-color: inherit;&#125;.roate::before &#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; background-color: yellowgreen; z-index: -1; width: 100%; height: 100%; transform-origin: bottom left; transform: rotate(-90deg); transition: transform 1s ease-in-out;&#125;.roate:hover::before &#123; transform: rotate(0deg);&#125; 原理是before里画一团颜色，用transform旋转让他塌下来 填充 123456789101112131415161718192021222324252627282930313233.btn2 &#123; margin: 5px; width: 400px; height: 50px; margin-top: 200px; position: relative; background-color: inherit; overflow: hidden; color: burlywood; transition: all 1.5s; font-size: 1rem;&#125;.btn2::before &#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; background-color: burlywood; width: 100%; height: 100%; z-index: -1; transform-origin: left; transform: translateX(-100%); transition: transform 1s ease-in-out;&#125;.btn2:hover::before &#123; transform: translateX(0);&#125;.btn2:hover &#123; color: white;&#125; 悬浮放大 12345678910111213141516171819.btn &#123; padding: 10px; position: relative; background-color: inherit; text-transform: uppercase; color: black; transition: all 1.5s; font-size: 1.25rem; border: 3px solid black; font-weight: 300; letter-spacing: 2px;&#125;.btn:hover&#123; font-weight: 900; letter-spacing: 5px; border: 5px solid black;&#125; 想不出来怎么形容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748a &#123; font-size: 2rem; display: flex; align-items: center; justify-content: center; color: black; text-decoration: none; margin: 25px; width: 160px; height: 60px; line-height: 60px; position: relative; transition: all 0.2s; letter-spacing: 3px; user-select: none; &amp;::before &#123; content: &quot;&quot;; position: absolute; width: 160px; height: 90px; top: -15px; left: 0; border-left: 4px solid #ff717f; border-right: 4px solid #353d81; transition: all 1s; &#125; &amp;:hover::before &#123; transform: rotateY(180deg); &#125; &amp;:hover::after &#123; transform: rotateX(180deg); &#125; &amp;::after &#123; content: &quot;&quot;; position: absolute; width: 200px; height: 60px; top: 0; left: -15px; border-top: 4px solid #ff717f; border-bottom: 4px solid #353d81; transition: all 1s; transition-delay: 0.2s; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/css/"}],"tags":[]},{"title":"计数排序","slug":"计数排序","date":"2024-10-08T12:01:06.000Z","updated":"2024-10-08T12:01:55.187Z","comments":true,"path":"2024/10/08/计数排序/","permalink":"https://0922wx.github.io/2024/10/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"第一眼 12345678910function countingSort(arr: number[]): number[] &#123; // Write your code here let len:number = arr.length const newArr:number[] = new Array(len).fill(0) for(let i =0;i&lt;len;i++)&#123; if(arr[i])&#123; &#125; &#125;&#125; 然后尬住了 拿到arr长度len 开辟长度为len的数组，并填充0 const newArr:number[] = new Array(len).fill(0) 第二眼 要求按arr最大值来定义数组长度，比如[1,1,3,2,1]的范围是[0…3],所以开辟res =[0,0,0,0] 所以得拿到最大值? 1const max = arr.find(...) find只能返回符合条件的第一个元素，不能找最大值 解构找到最大值 1const max = Math.max(...arr) reduce找到最大值 123const max =arr.reduce((acc,item) =&gt;&#123; return Math.max(acc,item)&#125;,arr[0]) acc当前最大值,item遍历元素 当然，acc是reduce原本就是接收的4个参数之一,还有个可选的initialValue Accumulator acc(累加器) Current Value cur(当前值) Current index idx(当前索引) Source Array src(源数组) 遍历arr 如果出现值，在特定位置计数加1 arr[i] newArr[i] ++ 第三眼 123456789function countingSort(arr: number[]): number[] &#123; // Write your code here let len:number = arr.length const max = Math.max(...arr) const newArr = Array(max).fill(0) for(let i=0;i&lt;len;i++)&#123; &#125;&#125; 相同数值再出现,再相同位置+1 有错 并非 const newArr = Array(max).fill(0) 而是 const newArr = Array(max + 1).fill(0) 为什么？ 因为要创建[0,max]全闭数组 第四眼 到底怎么计算元素出现次数? 123for(let num of arr)&#123; newArr[num]++&#125; 通过遍历输入数组 arr 中的每个数字 num，我们给 countArr[num] 这个位置的值加 1。 例如，如果输入数组是[2, 3, 2, 1]，则newArr将变为[0, 1, 2, 1] countArr[1] = 1 （数字 1 出现 1 次） countArr[2] = 2 （数字 2 出现 2 次） countArr[3] = 1 （数字 3 出现 1 次） 寄了 第五眼 看看洋人怎么写的 12345678 const frequencyArray = (new Array(100)).fill(0); const length = arr.length; for (let i = 0; i &lt; length; i++) &#123; frequencyArray[arr[i]] += 1; &#125; return frequencyArray;&#125; frequencyArray[arr[i]] += 1;疑似有点天才了","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"前言","slug":"前言","date":"2024-10-07T14:55:01.000Z","updated":"2024-10-07T15:16:17.697Z","comments":true,"path":"2024/10/07/前言/","permalink":"https://0922wx.github.io/2024/10/07/%E5%89%8D%E8%A8%80/","excerpt":"","text":"好好的力扣题不做，跑去刷洋人的题？","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"}],"tags":[]},{"title":"10-7","slug":"10-7","date":"2024-10-07T14:20:19.000Z","updated":"2024-10-25T15:30:34.848Z","comments":true,"path":"2024/10/07/10-7/","permalink":"https://0922wx.github.io/2024/10/07/10-7/","excerpt":"","text":"这个简爱 鲜奶米布丁 豪赤!🤓👍","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"Diagonal Difference对角线差","slug":"Diagonal-Difference","date":"2024-10-07T12:38:13.000Z","updated":"2024-10-07T12:56:06.214Z","comments":true,"path":"2024/10/07/Diagonal-Difference/","permalink":"https://0922wx.github.io/2024/10/07/Diagonal-Difference/","excerpt":"","text":"Diagonal Difference | HackerRank 计算矩阵的对角线差 力扣有道求对角线和 1572. 矩阵对角线元素的和 - 力扣（LeetCode） 只要你知道两边的对角线怎么求，一切都会好起来的 左边的对角线就arr[i][i],右边的的是arr[i][length-1-i] HackerRank让你求的是左右对角线的差的绝对值 1234567891011function diagonalDifference(arr: number[][]): number &#123; // Write your code here const length = arr.length let primarySum = 0; let secondarySum = 0 for (let i = 0; i &lt; length; i++) &#123; primarySum += arr[i][i]; secondarySum += arr[i][length - 1 - i]; &#125; return Math.abs(primarySum - secondarySum);&#125; 遍历途中记录就行了 力扣的是求和，还需要关心到元素项是不是偶数，(说起来求差不用关心吗)： 123456789var diagonalSum = function(mat) &#123; const length = mat.length const mid = Math.floor(length / 2) let sum = 0 for (let i = 0; i &lt; length; i++) &#123; sum += mat[i][i] + mat[i][length - 1 - i] &#125; return sum - mat[mid][mid] * (length &amp; 1)&#125;; return sum - mat[mid][mid] * (length &amp; 1) 检查是否是奇数，如果是奇数，即中间元素被计算了两次，所以要减一次中心元素值 为什么会重复计算？ 因为奇数项的话，会有一个中心值 1 2 3 4 5 6 7 8 9 第一轮 1+3 sum=4 5+5 sum=4+10 =14 这里算了两次 9+7 sum=14+16 = 30 length &amp; 1 &amp;与 两个位都为1时，结果才为1 如果length是偶数，那他二进制最后一位就是0，相反就是1 那为什么求差就不用考虑奇偶呢 因为是求差，相同的早变成0了，没有的东西就不用考虑了","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"Flipping bits","slug":"Flipping-bits","date":"2024-10-07T12:35:16.000Z","updated":"2024-10-07T12:37:35.306Z","comments":true,"path":"2024/10/07/Flipping-bits/","permalink":"https://0922wx.github.io/2024/10/07/Flipping-bits/","excerpt":"","text":"Flipping bits | HackerRank 给你一个32-bits位无符号整数的列表，要求你输出你把它们中每个数二进制表示中的每位翻转之后的结果得到的新列表（即0变成1，1变成0）。 属于是知道js有左移右移就能秒了 右移（&gt;&gt;） - JavaScript | MDN (mozilla.org) 1234function flippingBits(n: number): number &#123; // Write your code here return ~n &gt;&gt;&gt; 0; &#125; 翻译：按位取反并无符号右移32位","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"Grading Students","slug":"Grading-Students","date":"2024-10-07T07:16:53.000Z","updated":"2024-10-07T12:34:31.508Z","comments":true,"path":"2024/10/07/Grading-Students/","permalink":"https://0922wx.github.io/2024/10/07/Grading-Students/","excerpt":"","text":"Grading Students | HackerRank 1234567891011121314function gradingStudents(grades: number[]): number[] &#123; // Write your code here return grades.map(grades =&gt; &#123; if (grades &lt; 38) &#123; return grades &#125; const currentGrades: number = grades const nextFive = Math.ceil(grades / 5) * 5 if (nextFive - currentGrades &lt;3)&#123; return nextFive &#125; return currentGrades &#125;)&#125; map方法遍历数组，为其每项执行回调函数，返回新数组","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"Breaking the Records","slug":"Breaking-the-Records","date":"2024-10-07T07:15:11.000Z","updated":"2024-10-07T07:16:16.101Z","comments":true,"path":"2024/10/07/Breaking-the-Records/","permalink":"https://0922wx.github.io/2024/10/07/Breaking-the-Records/","excerpt":"","text":"Breaking the Records | HackerRank 1234567891011121314151617function breakingRecords(scores: number[]): number[] &#123; // Write your code here let minRecord = scores[0] let maxRecord = scores[0] let minCount = 0 let maxCount = 0 for(let i =0;i&lt;scores.length;i++)&#123; if(scores[i] &gt; maxRecord)&#123; maxRecord = scores[i] maxCount ++ &#125; else if(scores[i] &lt; minRecord)&#123; minRecord = scores[i] minCount++ &#125; &#125; return [maxCount,minCount]&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"Time Conversion","slug":"Time-Conversion","date":"2024-10-07T07:07:42.000Z","updated":"2024-10-07T07:14:13.378Z","comments":true,"path":"2024/10/07/Time-Conversion/","permalink":"https://0922wx.github.io/2024/10/07/Time-Conversion/","excerpt":"","text":"Time Conversion | HackerRank 给定12小时AM/PM格式的时间，将其转换为军用（24 小时）时间。 123456789101112131415161718function timeConversion(s) &#123; // Write your code here let [hours,minutes,seconds] = s.split(&quot;:&quot;) const period = seconds.slice(-2) //AM or PM seconds = seconds.slice(0, 2); hours = parseInt(hours) if(period === &#x27;AM&#x27;)&#123; if(hours === 12)&#123; hours = 0 &#125; &#125; else &#123; if(hours !== 12)&#123; hours +=12 &#125; &#125; const militratHours = String(hours).padStart(2,&#x27;0&#x27;) return `$&#123;militratHours&#125;:$&#123;minutes&#125;:$&#123;seconds&#125;`&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"Mini-Max Sum","slug":"Mini-Max-Sum","date":"2024-10-07T07:07:09.000Z","updated":"2024-10-07T07:12:27.873Z","comments":true,"path":"2024/10/07/Mini-Max-Sum/","permalink":"https://0922wx.github.io/2024/10/07/Mini-Max-Sum/","excerpt":"","text":"Mini-Max Sum | HackerRank 给定 5 个正整数，求 5 个整数中 4 个整数相加的最小值和最大值。然后将各自的最小值和最大值打印为一行两个空格分隔的长整数。 123456789101112function miniMaxSum(arr) &#123; // Write your code here let Max = Math.max(...arr) let Min = Math.min(...arr) let sum = 0 for (let item of arr) &#123; sum += item &#125; let minimun = sum - Max let maximum = sum - Min console.log(minimun,maximum)&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"Lonely Integer","slug":"Lonely-Integer","date":"2024-10-07T05:56:25.000Z","updated":"2024-10-07T07:05:06.513Z","comments":true,"path":"2024/10/07/Lonely-Integer/","permalink":"https://0922wx.github.io/2024/10/07/Lonely-Integer/","excerpt":"","text":"Lonely Integer | HackerRank 给定一个整数数组，其中除一个元素外所有元素都出现两次，请找出唯一的元素。 用set做 123456789101112function lonelyinteger(a: number[]): number &#123; // Write your code here const numSet =new Set&lt;number&gt;() for(const num of a)&#123; if(numSet.has(num))&#123; numSet.delete(num) &#125; else &#123; numSet.add(num) &#125; &#125; return Array.from(numSet)[0]&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"}],"tags":[]},{"title":"Sparse Arrays 稀疏阵列","slug":"Sparse-Arrays","date":"2024-10-07T05:34:19.000Z","updated":"2024-10-07T07:05:23.533Z","comments":true,"path":"2024/10/07/Sparse-Arrays/","permalink":"https://0922wx.github.io/2024/10/07/Sparse-Arrays/","excerpt":"","text":"Sparse Arrays | HackerRank 有一个输入字符串集合和一个查询字符串集合。对于每个查询字符串，确定它在输入字符串列表中出现的次数。返回结果数组。 Example strings = [‘ab’,‘ab’,‘abc’] queries = [‘ab’,‘abc’,'bc] 对于query，在返回数组result= [2,1,0] 1234567891011121314function matchingStrings(strings: string[], queries: string[]): number[] &#123; // Write your code here let res:number[] = [] for(let query of queries)&#123; let count = 0 for (let item of strings)&#123; if(item === query)&#123; count++ &#125; &#125; res.push(count) &#125; return res&#125;","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"Divisible Sum Pairs 可除和对","slug":"数组","date":"2024-10-07T05:02:44.000Z","updated":"2024-10-07T07:05:43.302Z","comments":true,"path":"2024/10/07/数组/","permalink":"https://0922wx.github.io/2024/10/07/%E6%95%B0%E7%BB%84/","excerpt":"","text":"看不太懂,先留着 可除数和对 | HackerRank — Divisible Sum Pairs | HackerRank 给定一个整数数组和一个正整数k ，求(i,j) 对中i&lt;j和ar[i] +ar[j] 能被k整除的个数。 123456789101112function divisibleSumPairs(n: number, k: number, ar: number[]): number &#123; // Write your code here let count = 0 const remainderCount = new Array(k).fill(0) for(let i=0;i&lt;n;i++)&#123; const remainder = ar[i] % k const neededRemainder = (k -remainder) % k count += remainderCount[neededRemainder] remainderCount[remainder]++ &#125; return count&#125; count: 用于记录满足条件的数对的数量，初始值设为 0。 remainderCount: 用于存储余数的出现次数。长度为 k 的数组，初始时所有值为 0。其目的在于记录每个余数（0 到 k-1）的出现次数，方便后续查找。 const remainder = ar[i] % k; 计算当前元素 ar[i] 对 k 的余数，这样可以确定这个数在模 k 的情况下的分类。 const neededRemainder = (k - remainder) % k; 通过上面的公式，我们可以确定要与当前数ar[i]配对的另一个数的余数： 如果 remainder 是 0，neededRemainder 也是 0，这意味着另一个数也应该是 0（即 ar[j] 的余数为 0）。 如果 remainder 是 1 且 k 是 5，则 neededRemainder 是 4，这意味着要找的另一个数的余数应该是 4，以使得它们的和（即 1 + 4）能够被 5 整除。 更新 count: count += remainderCount[neededRemainder]：这一步的作用是，如果当前数的余数为 remainder，我们通过查找 remainderCount 数组来获取之前有多少个数的余数是 neededRemainder。这些数可以和当前数成对，从而构成符合条件的和。 更新 remainderCount: remainderCount[remainder]++：这行代码是将当前数的余数 remainder 的计数加 1，因为我们在处理完当前数后，希望将它也加入到余数的计数中，供后续的元素使用。","categories":[{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"}],"tags":[]},{"title":"指定增删改链表思路","slug":"指定增删改链表思路","date":"2024-10-06T14:26:22.000Z","updated":"2024-10-06T14:36:55.548Z","comments":true,"path":"2024/10/06/指定增删改链表思路/","permalink":"https://0922wx.github.io/2024/10/06/%E6%8C%87%E5%AE%9A%E5%A2%9E%E5%88%A0%E6%94%B9%E9%93%BE%E8%A1%A8%E6%80%9D%E8%B7%AF/","excerpt":"","text":"连续做了HackerRank的链表题 怎么找到给定位置的节点前一项？(position以1开始计数，一般参数里有) 123456let currentNode = listlet currentPosition = 0while(currentNode !==null &amp;&amp; currentPosition &lt; position -1)&#123; currentNode = currentNode.next currentPosition++&#125; 增删改都是这样 记得判断链表为空的情况 记得判断给定位置在开头的情况 123if (position === 0) &#123; //xxxx&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"算法/链表","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"}],"tags":[]},{"title":"引入tailwind,className","slug":"引入tailwind-className","date":"2024-10-02T11:48:10.000Z","updated":"2024-10-02T12:34:48.835Z","comments":true,"path":"2024/10/02/引入tailwind-className/","permalink":"https://0922wx.github.io/2024/10/02/%E5%BC%95%E5%85%A5tailwind-className/","excerpt":"","text":"我用postcss插件，所以从Using PostCSS开始 12npm install -D tailwindcss postcss autoprefixernpx tailwindcss init 顺着官网就行了，只要注意main.css必须在src下 修改配置 1234567891011/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */module.exports = &#123; content: [&quot;./src/**/*.&#123;html,js,jsx,ts,tsx&#125;&quot;], theme: &#123; extend: &#123;&#125;, &#125;, plugins: [], corePlugins:&#123; preflight: false, &#125;&#125; 1npm install classnames 截至到此，已经完成初始化，以及绑定npm账号并已把组件库发布至npm的账号上了 回想一下遇到的奇事 1.package.json里的配置配错了 &quot;types&quot;: &quot;dist/index.d.ts&quot;写成了&quot;types&quot;: &quot;dist/type/index.d.ts&quot;, 导致我下载引入组件时报错，说找不到模块类型类型。 2.组件源码的src/index.ts没有导出任何组件，导致报错，别处下载引用时必须要带上wx-desginui/xx/xx/xx。 3.classNames和tailwind写的样式，有时候挺玄学的，如果双引号里稍微打个空格，或者没打空格，都会导致样式可能渲染不出来捏。 4.从原始人到现代人的过程：最开始调试样式或者测试组件功能时，仅通过发布npm更新，然后在别处下载引用通过这样子调试。这绝对不是什么常用的方法，于是我找到了另一种方法，不需要发布更新而在本地调试的方法： npm link 这需要另一个应用程序，这个方法还另有一个缺点：时间长了会断连接，需要重新连接。于是，找到了最新的方法：Storybook，仅本地调试，不需要再开另一个应用了。","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"组件库","slug":"项目/组件库","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"事前准备","slug":"项目/组件库/事前准备","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"}],"tags":[]},{"title":"写组件库，从第一个按钮开始编","slug":"写组件库，从第一个按钮开始编","date":"2024-10-02T11:45:11.000Z","updated":"2024-10-02T12:38:57.646Z","comments":true,"path":"2024/10/02/写组件库，从第一个按钮开始编/","permalink":"https://0922wx.github.io/2024/10/02/%E5%86%99%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%8C%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E5%BC%80%E5%A7%8B%E7%BC%96/","excerpt":"","text":"写一个组件？就我现在知道的事，应该分这几点 写好props类型，props的数量决定组件的自由度 没了 感觉无非就是先写一下interface，然后当作props传入组件就行了 比如我这个按钮，当然，简单的组件并不能说明什么，那些日历什么的倒真是麻烦得不行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React from &quot;react&quot;;import classNames from &quot;classnames&quot;;export interface ButtonProps &#123; title?: string; variant?: &quot;outlined&quot; | &quot;contained&quot;; onClick?: () =&gt; void; children?: React.ReactNode; disabled?: boolean; size?: &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;; rounded?: &quot;none&quot; | &quot;small&quot; | &quot;medium&quot; | &quot;large&quot;; icon?: React.ReactNode; iconPosition?: &quot;left&quot; | &quot;right&quot;;&#125;function Button(props: ButtonProps) &#123; const &#123; title, onClick, children, variant = &quot;contained&quot;, disabled, size = &quot;medium&quot;, rounded = &quot;small&quot;, icon, iconPosition = &quot;left&quot; &#125; = props; return ( &lt;button onClick=&#123;onClick&#125; className=&#123;classNames(&quot;px-2 cursor-pointer shadow-none text-sm&quot;, &#123; &quot;border-2 border-solid border-black bg-white text-black&quot;: variant === &quot;outlined&quot;, &quot; bg-black text-white border-none&quot;: variant === &quot;contained&quot;, &quot;pointer-events-none cursor-not-allowed pointer-event-none bg-gray-300 border-none &quot;: disabled, &quot;h-8&quot;: size === &quot;small&quot;, &quot;h-10&quot;: size === &quot;medium&quot;, &quot;h-12&quot;: size === &quot;large&quot;, &quot;rounded-none&quot;: rounded === &quot;none&quot;, &quot;rounded-sm&quot;: rounded === &quot;small&quot;, &quot;rounded-md&quot;: rounded === &quot;medium&quot;, &quot;rounded-lg&quot;: rounded === &quot;large&quot;, &quot;flex gap-3 items-center&quot;:icon, &quot;flex-row-reverse&quot;:icon &amp;&amp; iconPosition === &quot;right&quot; &#125;)&#125; &gt; &#123;icon &amp;&amp; icon&#125; &#123;title || children&#125; &lt;/button&gt; );&#125;export default Button;","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"组件库","slug":"项目/组件库","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/"}],"tags":[]},{"title":"rollup基本构建","slug":"rollup基本构建","date":"2024-10-02T05:04:51.000Z","updated":"2024-10-06T10:10:33.607Z","comments":true,"path":"2024/10/02/rollup基本构建/","permalink":"https://0922wx.github.io/2024/10/02/rollup%E5%9F%BA%E6%9C%AC%E6%9E%84%E5%BB%BA/","excerpt":"","text":"从npm init开始编 1npm i react typescript @types/react tslib --save-dev 新建tsconfig.json 1234567891011121314151617181920&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;esModuleInterop&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;noFallthroughCasesInSwitch&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;noEmit&quot;: true, &quot;jsx&quot;: &quot;react-jsx&quot; &#125;, &quot;include&quot;: [&quot;src&quot;]&#125; 构建rollup 1npm i react typescript @types/react ts-lib --save-dev 12345678rollup //构建源代码并输出，起点@rollup/plugin-typescript //处理ts语法与转换@rollup/plugin-node-resolve //解析插件,把模块转化成js@rollup/plugin-commonjs //将commonjs转换成es6语法rollup-plugin-dts //生成类型文件的ts插件 生成组件的类型@rollup/plugin-terser //最小化代码rollup-plugin-peer-deps-external //排除指定的npm模块，对等依赖tslib rollup.config.ts 123456789101112131415161718192021222324252627282930313233343536import resolve from &quot;@rollup/plugin-node-resolve&quot;;import commonjs from &quot;@rollup/plugin-commonjs&quot;;import typescript from &quot;@rollup/plugin-typescript&quot;;import terser from &quot;@rollup/plugin-terser&quot;;import peerDeps from &quot;rollup-plugin-peer-deps-external&quot;;import &#123; dts &#125; from &quot;rollup-plugin-dts&quot;;export default [ &#123; input: &quot;src/index.ts&quot;, // 入口文件 output: [ &#123; file: &quot;dist/cjs/index.js&quot;, format: &quot;cjs&quot;, sourcemap: true, &#125;, //cjs &#123; file: &quot;dist/esm/index.js&quot;, format: &quot;esm&quot;, sourcemap: true, &#125;, //esm ], plugins: [ peerDeps(), //解决对等依赖关系 resolve(), // 解析node_modules中的模块 commonjs(), // 转换commonjs模块 typescript(), // 编译typescript terser(), //压缩代码 ], &#125;, &#123; input: &quot;src/index.ts&quot;, // 类型入口文件 output: [&#123; file: &quot;dist/index.d.ts&quot;, format: &quot;es&quot; &#125;], // 生成类型 plugins: [dts()], // 编译类型文件 &#125;,]; package.json 123456789101112131415161718192021222324252627282930&#123; &quot;name&quot;: &quot;wx-ui&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;dist/cjs/index.js&quot;, &quot;module&quot;: &quot;dist/esm/index.js&quot;, &quot;types&quot;: &quot;dist/index.d.ts&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;rollup -c --bundleConfigAsCjs&quot; &#125;, &quot;author&quot;: &quot;wx&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;description&quot;: &quot;&quot;, &quot;devDependencies&quot;: &#123; &quot;@types/react&quot;: &quot;^18.3.10&quot;, &quot;react&quot;: &quot;^18.3.1&quot;, &quot;ts-lib&quot;: &quot;^0.0.5&quot;, &quot;typescript&quot;: &quot;^5.6.2&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;@rollup/plugin-commonjs&quot;: &quot;^28.0.0&quot;, &quot;@rollup/plugin-node-resolve&quot;: &quot;^15.3.0&quot;, &quot;@rollup/plugin-terser&quot;: &quot;^0.4.4&quot;, &quot;@rollup/plugin-typescript&quot;: &quot;^12.1.0&quot;, &quot;rollup&quot;: &quot;^4.23.0&quot;, &quot;rollup-plugin-dts&quot;: &quot;^6.1.1&quot;, &quot;rollup-plugin-peer-deps-external&quot;: &quot;^2.2.4&quot;, &quot;tslib&quot;: &quot;^2.7.0&quot; &#125;&#125; npm run build 成功后生成dist文件夹(cjs,esm,index.d.ts)","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"组件库","slug":"项目/组件库","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"事前准备","slug":"项目/组件库/事前准备","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"}],"tags":[]},{"title":"完成imagekit认证前置","slug":"完成imagekit认证前置","date":"2024-10-01T06:39:43.000Z","updated":"2024-10-01T07:00:02.013Z","comments":true,"path":"2024/10/01/完成imagekit认证前置/","permalink":"https://0922wx.github.io/2024/10/01/%E5%AE%8C%E6%88%90imagekit%E8%AE%A4%E8%AF%81%E5%89%8D%E7%BD%AE/","excerpt":"","text":"依据ImageKit的官方文档，我们需要在后台SDK传入API公钥，私钥和URL端点，前面已经配置好了。 但是，想要将图片上传到imagekit的媒体库，还需要后端服务器用私有密钥对请求进行验证 怎么验证？ 使用imagekit-nestjs封装好的方法 我这里新建了user模块 1nest g resource user 123456789101112131415//user.controller.tsimport &#123; Controller, Get &#125; from &#x27;@nestjs/common&#x27;;import &#123; UserService &#125; from &#x27;./user.service&#x27;;@Controller(&#x27;user&#x27;)export class UserController &#123; constructor( private readonly userService: UserService) &#123;&#125; @Get(&#x27;keys&#x27;) async getImageKitKeys() &#123; const res = await this.userService.getAuthParameters(); return res; &#125;&#125; 1234567891011121314//user.service.tsimport &#123; Injectable &#125; from &#x27;@nestjs/common&#x27;;import &#123; ImageKitService &#125; from &quot;imagekit-nestjs&quot;;@Injectable()export class UserService &#123; constructor(private readonly imageKitService: ImageKitService) &#123;&#125; // 通过构造函数注入 ConfigService async getAuthParameters()&#123; // 获取 ImageKit 的认证参数 const keys = await this.imageKitService.getAuthenticationParameters(); return keys; // 返回密钥 &#125;&#125; 开启跨域 12345678910//main.tsimport &#123; NestFactory &#125; from &#x27;@nestjs/core&#x27;;import &#123; AppModule &#125; from &#x27;./app.module&#x27;;async function bootstrap() &#123; const app = await NestFactory.create(AppModule); app.enableCors(); await app.listen(3005);&#125;bootstrap(); 启动服务 1nest start 根据官方文档所说，如果成功的话会返回三个参数 用postman试一下 完成! 寥寥数笔，花了我三个多小时🫤 参考 CodeVisionEvgen/imagekit-nestjs: Imagekit nestjs module (github.com) React (imagekit.io) API keys (imagekit.io) Nest 通关秘籍 - zxg_神说要有光 - 掘金小册 (juejin.cn)","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"表情包制作","slug":"项目/表情包制作","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%A1%A8%E6%83%85%E5%8C%85%E5%88%B6%E4%BD%9C/"}],"tags":[]},{"title":"在nest中使用Imagekit.io","slug":"9-30","date":"2024-09-30T13:43:32.000Z","updated":"2024-10-01T03:33:11.247Z","comments":true,"path":"2024/09/30/9-30/","permalink":"https://0922wx.github.io/2024/09/30/9-30/","excerpt":"","text":"nest中构建imagekit.io服务 1npm install imagekit-nestjs 1npm install @nestjs/config 创建configs/imagekit.config.ts 12345678910import &#123; ConfigService &#125; from &quot;@nestjs/config&quot;;import &#123; ImageKitModuleOptions &#125; from &quot;imagekit-nestjs&quot;;export const ImageKitConfig = ( configService: ConfigService): ImageKitModuleOptions =&gt; (&#123; privateKey: configService.get(&quot;IMAGEKIT_PRIVATE_KEY&quot;), publicKey: configService.get(&quot;IMAGEKIT_PUBLIC_KEY&quot;), urlEndpoint: configService.get(&quot;IMAGEKIT_URL_ENDPOINT&quot;),&#125;); 根目录下创建.env文件 123IMAGEKIT_PUBLIC_KEY=&#x27;&#x27;IMAGEKIT_PRIVATE_KEY=&#x27;&#x27;IMAGEKIT_URL_ENDPOINT=&#x27;&#x27; 在AppModule中注入,允许环境变量全局可用 123456789101112131415161718192021222324import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;import &#123; AppController &#125; from &#x27;./app.controller&#x27;;import &#123; AppService &#125; from &#x27;./app.service&#x27;;import &#123; ConfigModule, ConfigService &#125; from &#x27;@nestjs/config&#x27;;import &#123; ImageKitModule &#125; from &#x27;imagekit-nestjs&#x27;;import &#123; ImageKitConfig &#125; from &#x27;./configs/imagekit.config&#x27;;@Module(&#123; imports: [ ConfigModule.forRoot(&#123; isGlobal: true, &#125;), ImageKitModule.forRootAsync(&#123; useFactory: ImageKitConfig, inject: [ConfigService], imports: [ConfigModule], isGlobal: true, // is optional &#125;), ], controllers: [AppController], providers: [AppService],&#125;)export class AppModule &#123;&#125; 完成 一些错误 报错 Error: Missing publicKey during ImageKit initialization 控制台打印后发现publickey和private都是undefined 这里是因为没有创建.env设置变量，而且没有把他变成全局可用导致的","categories":[{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"表情包制作","slug":"项目/表情包制作","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%A1%A8%E6%83%85%E5%8C%85%E5%88%B6%E4%BD%9C/"}],"tags":[]},{"title":"迪火一面","slug":"迪火一面","date":"2024-09-27T08:25:18.000Z","updated":"2024-10-16T07:40:32.488Z","comments":true,"path":"2024/09/27/迪火一面/","permalink":"https://0922wx.github.io/2024/09/27/%E8%BF%AA%E7%81%AB%E4%B8%80%E9%9D%A2/","excerpt":"","text":"第一次面试记录 迪火 一面 半个小时 提问没按顺序排 自我介绍 JS基本数据类型 判断数组有几种方法 你刚刚提到了call，call的作用是什么？(绑定this指向)，call和apply有什么区别？ 主题切换可以怎么做？ antd组件怎么导入的？如果我导入组件时只写from 'antd',组件还能成功导入吗？打包会把所有东西都打包吗？ rem和em有什么区别？ 如何避免样式类名污染？(module.css)，原理？(给类名一个唯一值) 用过vue吗，vue是如何处理样式类名污染的？(scope)原理？ 如何让一个弹窗居中 开发中的Package.Lock.json有什么作用？ Package.json里的^和~的作用？ react条件渲染时为什么要加个key值？(优化diff算法)不加key会报错吗？ 用过redux吗，解释一下他的工作流程 如果有很多条数据需要以列表渲染，该怎么做（虚拟列表，byd没好好看结果问到了） 项目相关 做项目遇到的难点 Js基本数据类型 原始数据类型包括： 字符串（String） 数字（Number） 布尔（Boolean） 空（Null）：表示没有任何值，通常用于赋值给可能会不存在的变量。 未定义（Undefined）：变量已声明但未赋值时的状态。 Symbol：ES6 引入的新类型，表示唯一的值，常用于对象属性名以保证不会出现同名属性。 BigInt：谷歌67版本中还出现了一种 bigInt。是指安全存储、操作大整数。（但是很多人不把这个做为一个类型，不过我就爱说）。 引用类型： 对象（Object） 数组（Array） 函数（Function） 1+1等于几的难度，答不上来可以重开了","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"反思三道动态规划题","slug":"反思三道动态规划题","date":"2024-09-27T05:57:21.000Z","updated":"2024-09-27T08:25:28.967Z","comments":true,"path":"2024/09/27/反思三道动态规划题/","permalink":"https://0922wx.github.io/2024/09/27/%E5%8F%8D%E6%80%9D%E4%B8%89%E9%81%93%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98/","excerpt":"","text":"先了解一点，动态规划(Dynamic Programming)是一种思路，将一个复杂的问题分解为更简单的子问题，通过对每个子问题只求解一次并存储结果，这是一个自底向上的过程，通过定位已知和未知之间的关系来进行推导。 从本质上讲，这是一个简单的想法，在用给定的输入解决一个问题后，将结果保存为参考，以便将来使用，这样你就不必重新解决问题了…简而言之，就是 &quot;记住你的过去&quot;🫠。 这个方法可以用递归或者迭代算法来实现，递归算法是通过递归方式找到子问题的解决方案，迭代算法则是通过按特定顺序处理子问题来找到解决方案。(原地tp) 思路历程约等于递归+记忆搜索。当然，这和递归有区别，因为用递归的话，OJ会判定超时。 DP是如何工作的？ 确定子问题:将主要问题划分为更小而独立的子问题。 存储解决方案:解决每个子问题并将解决方案存储在表格或者数组中。 建立解决方案:使用存好的解决方案建立主要问题的解决方案。 避免冗余:通过存储解决方案，DP可确保每个子问题只需要求解一次，从而减小计算时间。 什么时候使用动态规划？ 两个必要条件: 最优子结构 重叠子问题 那么步骤呢？ 确定他是否属于动态规划问题。 找到状态表达式。（倒推的过程） 确定状态和状态转换的关系。 制表（或者备忘录，反正和记忆搜索大差不差，就是现存储一些算好的结果，空间换时间） 爬楼梯 题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 基于动态规划的思想分析 首先做到倒着分析，即: 定位到问题终点 站在终点的角度，思考后退的可能 这题为什么可以用动态规划？体现在——不管前面的决策如何，此后的状态必须基于当前状态的最优决策。比如爬楼梯，我们要想站在第n阶楼梯，该如何达到？无非两种情况：一种从n-1阶爬上来；一种是从n-2阶爬上来。即 f(n) = f(n-1) + f(n-2)(找到状态转移方程) 人话:站在n阶，往后退只能退一步或者两步，对于每一阶楼梯皆是如此。 f(n-2) = f(n-3) + f(n-4) f(n-3) = f(n-4) + f(n-5) … 这是一个重复计算的过程，也符合重叠子问题这一特征 可以把他转为一个树型模型 .rghlejlcojiq{zoom: 50%;} 解法 我们已经找到了状态转移方程 f(n) = f(n-1) + f(n-2) 以 f(1) 和 f(2) 为起点，不断求和，循环递增 n 的值，我们就能够求出f(n)了 1234567891011121314151617/*** @param &#123;number&#125; n* @return &#123;number&#125;*/const climbStairs = function(n) &#123; // 初始化状态数组 const dp = []; // 初始化已知值 dp[1] = 1; dp[2] = 2; // 动态更新每一层楼梯对应的结果 for(let i = 3;i &lt;= n;i++)&#123; dp[i] = dp[i-2] + dp[i-1]; &#125; // 返回目标值 return dp[n];&#125;; 分析技巧 递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系 结合记忆化搜索，明确状态转移方程 递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。 不同路径 题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（标记为 “Finish” ）。 问总共有多少条不同的路径？ 输入：m = 3, n = 7 输出：28 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向下 那么，先倒着分析，当前位置我们有哪些可选方向的 当前只能往下,dp[i][j] = dp[i-1][j] 当前只能往右,dp[i][j] = dp[i][j-1] 当前又能下又能右， dp[i][j]=dp[i][j−1]+dp[i−1][j] 那么状态转移方程势必为 1dp[i][j] = dp[m-1][n]+ dp[m][n-1] 为什么是-1？ 没有为什么，因为起点是(0,0)，总共m行n列。 接着找初始条件，也就是起点 1dp[0][0] = 1 为什么初始条件是这个？ 因为这是开始移动的起点，这个位置到自身的路径是唯一的。 (想一下，从(0,0)到(0,0)的方法是不是只有一种) 解法 123456789101112131415161718192021/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var uniquePaths = function (m, n) &#123; // 初始化一个 m x n 的二维数组 let f = Array.from(&#123; length: m &#125;, () =&gt; Array(n).fill(0)); f[0][0] = 1; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (i &gt; 0) &#123; f[i][j] += f[i - 1][j]; // 往下 &#125; if (j &gt; 0) &#123; f[i][j] += f[i][j - 1]; // 往右 &#125; &#125; &#125; return f[m - 1][n - 1];&#125; 还有一道晚点写 参考 Dynamic Programming or DP - GeeksforGeeks 前端算法与数据结构面试：底层逻辑解读与大厂真题训练 - 修言 - 掘金小册 (juejin.cn) 动态规划路径问题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"虚拟dom","slug":"虚拟dom","date":"2024-09-23T09:41:33.000Z","updated":"2024-09-23T10:05:26.190Z","comments":true,"path":"2024/09/23/虚拟dom/","permalink":"https://0922wx.github.io/2024/09/23/%E8%99%9A%E6%8B%9Fdom/","excerpt":"","text":"构思一下面试怎么回答这个问题。 为什么要使用虚拟dom 相对于操作真实dom更加方便（性能而言自然是操作真实的要好，因为那是命令式编程） 相比于innerHTML，虚拟dom在更新的时候比他性能更高（innerHTML需要销毁所有旧的dom ，再解析新的字符串，最后重新创建所有dom节点） 虚拟dom仅需要两层计算：用diff算法计算更新的节点，然后更新必要的dom就行了 总结：虚拟dom能够防止组件在重渲染时导致的性能恶化， 而且还能批量更新（收集多个更新操作然后一次性将这些更改应用到真实dom上） 减少不必要的dom操作， 跨平台","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[]},{"title":"9-21即将到来的第一次面试","slug":"9-21","date":"2024-09-21T10:03:57.000Z","updated":"2024-10-25T15:28:43.286Z","comments":true,"path":"2024/09/21/9-21/","permalink":"https://0922wx.github.io/2024/09/21/9-21/","excerpt":"","text":"9.24号有线上面试，紧张准备中– 无论是不是刷kpi，都应该认真面对。 10.25认真你妈，随便说几句得了，反正又不真招人","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"Bind Apply Call的区别","slug":"BAC","date":"2024-09-21T09:04:50.000Z","updated":"2024-09-21T10:03:04.284Z","comments":true,"path":"2024/09/21/BAC/","permalink":"https://0922wx.github.io/2024/09/21/BAC/","excerpt":"","text":"相通点:都可以改变this 指向 为什么要改变this指向？ 123456789var name = &quot;wx&quot;;let obj =&#123; name:&quot;abc&quot;, say:function() &#123; console.log(this.name); &#125;,&#125;;obj.say();//显示abcsetTimeout(obj.say,10);//显示wx (实际我把var换成let或者const就不会打印出什么东西，因为那不再是全局变量，而是块级，输出一片空白捏) 同样调用obj,say,为什么结果不同呢?（涉及this绑定规则） setTimeout所指向为window对象，其中的say方法是作为回调函数执行的，其中所传递的是函数的引用，并没有保留这个函数所属的对象，那么setTimeout调用函数时，其中的this取决于调用时的执行上下文(这里并没有指定上下文，所以10毫秒后在全局执行环境执行，浏览器自动绑定window。) 那么此时，如果想修改say方法中的this，就需要改变this指向了。 apply绑定this 123setTimeout(function()&#123; obj.say.apply(obj);&#125;,10);//输出abc 参数传递：参数是在调用新函数时传递给它的参数。 (将所有参数放到一个数组里去) 调用时立即执行方法 比如 123456789let obj =&#123; name:&quot;abc&quot;, say:function(param1,param2) &#123; console.log(param1 +&quot;,&quot; + param2 +&quot;,&quot;+ this.name); &#125;,&#125;;setTimeout(function() &#123; obj.say.apply(obj,[&quot;hello&quot;,&quot;world&quot;])&#125;,10) call绑定this 跟apply差不多，唯一的区别是他需要的参数并非是一个数组，而是依次传入 调用时立即执行方法 所以需要注意与参数一一对应。 123setTimeout(function() &#123; obj.say.call(obj,&quot;hello&quot;,&quot;world&quot;)&#125;,10) bind绑定this 与其他两者最大的区别是，bind返回值是一个新的函数 调用时不直接执行 12let newFun = obj.say.bind(obj,&quot;hello&quot;,&quot;world&quot;);newFun(); 也不需要一次性传入所有参数 12let newFun = obj.say.bind(obj);newFun(&quot;hello&quot;,&quot;world&quot;); this的绑定规则 this和函数定义的位置没有关系，只和调用者有关系 在运行时被绑定 1234567891011121314function foo()&#123; console.log(this);&#125;foo();//windowvar obj = &#123; name:&quot;wx&quot;, foo:foo&#125;obj.foo()// objfoo.call(&quot;abc&quot;) // string&#123; &quot;abc&quot; &#125; 隐式绑定 1.通过对象调用函数绑定this 谁直接调用foo()，this就指向谁。 当然，这有个前置条件：对象所调用的函数必须是对象的属性。 123456789function foo()&#123; console.log(this);&#125;var obj = &#123; name:&quot;wx&quot;, foo:foo&#125;obj.foo() 显式绑定 如果obj对象上没有定义某个方法，但又想通过obj这个对象来调用这个方法？ 也就是最上面的call,apply,bind了 new绑定this 123456function Student(name)&#123; console.log(this)// student &#123;&#125; this.name = name; &#125;var wx = new Student(&quot;abc&quot;);console.log(wx); //student&#123;name:&#x27;abc&#x27;&#125; 涉及面试题：new 关键字创建一个新对象的步骤？ 构造函数如何创建新对象？ 1.创建一个空对象。 2.空对象的-proto-属性指向构造函数的Prototype属性。 3.执行构造函数，如果构造函数中有this，则此this指向刚刚创建的空对象。 4.返回刚刚创建的对象。 返回值？ 在构造函数中，如果有return的话会返回什么？ 12345678910function Student(name)&#123; console.log(this) this.name = name; return &#123; name:&quot;我是对象&quot; &#125;&#125;var wx = new Student(&quot;abc&quot;);console.log(wx); // &#123;name:&quot;我是新对象&quot;&#125; 如果return的是对象，则直接返回对象 如果return的是基本类型，则return语句无效，仍然返回刚刚创建的新对象。 如果多种绑定都存在，优先级？ 隐式绑定和显式绑定同时存在，显式绑定优先级更高 new绑定优先级高于隐式绑定(隐式垫底了说是) new绑定优先级高于bind 总结：new &gt; 显式(bind)&gt;隐式","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"}],"tags":[]},{"title":"受控组件与非受控组件","slug":"受控组件与非受控组件","date":"2024-09-16T12:49:11.000Z","updated":"2024-09-16T12:57:16.001Z","comments":true,"path":"2024/09/16/受控组件与非受控组件/","permalink":"https://0922wx.github.io/2024/09/16/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/","excerpt":"","text":"今天用 shadn ui 的 form 组件，其中提到了这是个受控组件，起初我还没注意。后面调试的时候发现我一往 input 里面 写东西，控制台就疯狂报错 Warning: A component is changing an uncontrolled input of type text to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: 第一次在实际中遇到受控组件因为没有默认值报错，复习一下： 涉及到输入，就绕不开受控模式和非受控模式的概念。改变表单值只有两种情况： 用户去改变 value 或者代码去改变 value。 如果不能通过代码改表单值 value，那就是非受控，也就是不受我们控制。 但是代码可以给表单设置初始值 defaultValue。 代码设置表单的初始 value，但是能改变 value 的只有用户，代码通过监听 onChange 来拿到最新的值，或者通过 ref 拿到 dom 之后读取 value。 这种就是非受控模式。 反过来，代码可以改变表单的 value，就是受控模式。 value 由用户控制就是非受控模式，由代码控制就是受控模式。","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[]},{"title":"9-16又和项目搏斗了一天","slug":"9-16","date":"2024-09-16T12:46:53.000Z","updated":"2024-10-01T06:45:29.049Z","comments":true,"path":"2024/09/16/9-16/","permalink":"https://0922wx.github.io/2024/09/16/9-16/","excerpt":"","text":"完全不知道做什么捏，只是弄好了一个dashboard而已，然后加了个toDoList，后面再优化一下好了。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"9-13中秋节再冲一次吧","slug":"9-13","date":"2024-09-13T12:30:06.000Z","updated":"2024-10-01T06:45:31.427Z","comments":true,"path":"2024/09/13/9-13/","permalink":"https://0922wx.github.io/2024/09/13/9-13/","excerpt":"","text":"9月很重要啊，得再敲一个项目出来。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"9-8有那么一点点拨云见日了","slug":"9-8","date":"2024-09-08T12:04:03.000Z","updated":"2024-10-01T06:45:33.182Z","comments":true,"path":"2024/09/08/9-8/","permalink":"https://0922wx.github.io/2024/09/08/9-8/","excerpt":"","text":"跟着学了一个日历组件的搭建，稍微理清了props传值，usecontext，条件渲染这些东西了 还没弄完，先沉淀一下吧。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"事件循环","slug":"事件循环","date":"2024-09-07T05:55:53.000Z","updated":"2024-09-07T06:00:40.151Z","comments":true,"path":"2024/09/07/事件循环/","permalink":"https://0922wx.github.io/2024/09/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"事件循环包括三个部分： 1.主线程 2.宏队列：异步操作（如Ajax请求，定时器） 3.微队列：Promise回调等 顺序： 先执行主线程，遇到宏任务就放到宏队列，遇微任务放到微队列 主线程执行完毕，优先开始处理微队列，再执行宏队列，如此循环 事件循环是JavaScript非阻塞行为的关键。","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"}],"tags":[]},{"title":"9-6连滚带爬的做完了","slug":"9-6","date":"2024-09-06T12:28:15.000Z","updated":"2024-10-01T06:45:35.823Z","comments":true,"path":"2024/09/06/9-6/","permalink":"https://0922wx.github.io/2024/09/06/9-6/","excerpt":"","text":"没想到真的赶在开学前做好tutu会客室了，哇偶。 接下来就做组件库吧，这样就没有后端的烦恼了。 溜八股了，不过在此之中。 也需要大玩特玩星际战士。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"9-5噩耗：后天开学","slug":"9-5","date":"2024-09-05T13:12:03.000Z","updated":"2024-10-01T06:45:11.986Z","comments":true,"path":"2024/09/05/9-5/","permalink":"https://0922wx.github.io/2024/09/05/9-5/","excerpt":"","text":"伪人即将开学👽","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"天才的第一步","slug":"动态规划","date":"2024-09-04T12:02:31.000Z","updated":"2024-09-04T12:12:58.622Z","comments":true,"path":"2024/09/04/动态规划/","permalink":"https://0922wx.github.io/2024/09/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"首先记住两个特征： 1.要求给出达成某种目的的解法个数 2.不要求你给出每一种解法对应的具体路径 核心思想就是穷举求最值。 只有列出正确的状态转移方程，才能正确穷举，而且需要判断算法是否具备最优子结构是否能够通过子问题的最值得到原问题的最值。 外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。 (看不懂) 重叠子问题、最优子结构、状态转移方程就是动态规划三要素，动态规划是自底向上的过程，它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"9-2世界是一个巨大的蓝色链接","slug":"9-2","date":"2024-09-02T13:14:25.000Z","updated":"2024-10-01T06:44:33.493Z","comments":true,"path":"2024/09/02/9-2/","permalink":"https://0922wx.github.io/2024/09/02/9-2/","excerpt":"","text":"目前所有的算法知识来源于两个地方，一个叫labuladong的算法笔记(花了我两百大洋),一个是稀土掘金的前端数据结构与算法(四十大洋)。 这个算法笔记确实是全啊，但是每当我想按顺序看内容的时候，字里行间总会出现蓝色链接的字。我不点进去看吧，他说他已经在蓝字里总结这些知识，不看 总觉得亏，也不利于下文的理解；我点进去看吧，里面又是一堆蓝色链接👽。于是层层递进，层层嵌套，我便不停的点进去，像是中了DFS的毒。😵‍💫 世界是一个巨大的蓝色链接 (今天也是换了渲染引擎，可以发表情了)","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"二叉树前置思想","slug":"二叉树思路","date":"2024-09-02T12:40:03.000Z","updated":"2024-09-02T13:11:55.831Z","comments":true,"path":"2024/09/02/二叉树思路/","permalink":"https://0922wx.github.io/2024/09/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%9D%E8%B7%AF/","excerpt":"","text":"快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历。(听说高手都是这么想的) 所以先打点基础吧。 快排算法思路 代码框架 1234567891011const sort = function(nums, lo, hi) &#123; if (lo &gt;= hi) &#123; return; &#125; // 对 nums[lo..hi] 进行切分 // 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi] let p = partition(nums, lo, hi); // 去左右子数组进行切分 sort(nums, lo, p - 1); sort(nums, p + 1, hi);&#125;; 对比二叉树前序遍历 1234567891011// 二叉树遍历框架const traverse = function(root) &#123; if (root === null) &#123; return; &#125; // ***** 前序位置 ***** console.log(root.val); // ******************* traverse(root.left); traverse(root.right);&#125;; 一句话总结快速排序：快速排序是先将一个元素排好序，然后再将剩下的元素排好序。 快速排序的核心无疑是 partition 函数， partition 函数的作用是在 nums[lo..hi] 中寻找一个切分点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p] 一个元素左边的元素都比它小，右边的元素都比它大，所以 partition 函数干的事情，其实就是把 nums[p] 这个元素排好序了。 从二叉树的视角，我们可以把子数组 nums[lo..hi] 理解成二叉树节点上的值，sort 函数理解成二叉树的遍历函数。 partition 函数每次都将数组切分成左小右大两部分，恰好和二叉搜索树左小右大的特性吻合。 欸☝️🤓，那快速排序的过程可不就是是一个构造二叉搜索树的过程。 但是二叉搜索树不平衡的极端情况，需要引入随机性，比如洗牌算法。当然这种东西就不是现在的我能碰瓷的了，随便记一下就好了。 快速排序代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const quickSort = function(nums) &#123; // 排序整个数组（原地修改） sort(nums, 0, nums.length - 1);&#125;;const sort = function(nums, lo, hi) &#123; if (lo &gt;= hi) &#123; return; &#125; // 对 nums[lo..hi] 进行切分 // 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi] let p = partition(nums, lo, hi); sort(nums, lo, p - 1); sort(nums, p + 1, hi);&#125;;// 对 nums[lo..hi] 进行切分const partition = function(nums, lo, hi) &#123; let pivot = nums[lo]; // 关于区间的边界控制需格外小心，稍有不慎就会出错 // 这里把 i, j 定义为开区间，同时定义： // [lo, i) &lt;= pivot；(j, hi] &gt; pivot // [lo, i) &lt;= pivot; (j, hi] &gt; pivot // 之后都要正确维护这个边界区间的定义 let i = lo + 1, j = hi; // 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖 while (i &lt;= j) &#123; while (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123; i++; // 此 while 结束时恰好 nums[i] &gt; pivot &#125; while (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123; j--; // 此 while 结束时恰好 nums[j] &lt;= pivot &#125; if (i &gt;= j) &#123; break; &#125; // 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot // 交换 nums[j] 和 nums[i] [nums[i], nums[j]] = [nums[j], nums[i]]; // 此时 [lo, i] &lt;= pivot &amp;&amp; [j, hi] &gt; pivot &#125; // 最后将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大 [nums[lo], nums[j]] = [nums[j], nums[lo]]; return j;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"算法/二叉树","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[]},{"title":"React组件的TS类型","slug":"React组件的TS类型","date":"2024-09-02T12:10:34.000Z","updated":"2024-09-08T10:26:06.247Z","comments":true,"path":"2024/09/02/React组件的TS类型/","permalink":"https://0922wx.github.io/2024/09/02/React%E7%BB%84%E4%BB%B6%E7%9A%84TS%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"平时常用的类型在@types/react这个包里，cra已经引入了。 JSX类型 如果你想描述一个jsx类型，使用React.ReactElement。 比如 1234interface AaaProps &#123; name:string; content:React.Reactelement&#125; 这样就只能传入jsx类型 如果有时需要传入number,null呢？ 换成ReactNode就好了 1234interface AaaProps &#123; name:string; content:React.ReactNode&#125; ReactNode 包含 ReactElement、或者 number、string、null、boolean 等可以写在 JSX 里的类型。 这三个类型的关系 ReactNode &gt; ReactElement &gt; JSX.Element。 所以，一般情况下，如果你想描述一个参数接收 JSX 类型，就用 ReactNode 就行。 函数组件类型 FC 和 FunctionComponent 等价，参数是 Props，返回值是 ReactNode 1234567const Aaa:React.FunctionComponent&lt;AaaProps&gt; = (props) =&gt;&#123; return &lt;div&gt;aaa,&#123;props.name&#125;&#123;props.content&#125;&lt;/div&gt;&#125;function Aaa2(props:AaaProps) &#123; return &lt;div&gt;aaa,&#123;props.name&#125;&#123;props.content&#125;&lt;/div&gt;&#125; 类型定义 123456789type FC&lt;p = &#123;&#125;&gt; = FunctionComponent&lt;p&gt;interface FuctionComponent&lt;p = &#123;&#125;&gt; &#123; (props: P ,context?:any):ReactNode; propsTypes?: WeakValidationMap&lt;p&gt; | undefined; contextTypes?: ValidationMap&lt;p&gt; | undefined; defultProps?: Partial&lt;p&gt; | undefined; displayNmae?: string | undefined;&#125; Hook的类型 useState 一般用推导的类型，或者手动声明。 useEffect 和 useLayoutEffect 没有类型参数。 useRef 作为可以保存dom引用或者其他内容的钩子，它的类型有两种。 保存dom引用时，参数需要传个null，不然会报错 1const ref = useRef&lt;HTMLDivElement&gt;(null) 而保存别的内容的时候，不能传 null，不然也会报错，说是 current 只读,原因是当你传入 null 的时候，返回的是 RefObject，它的 current 是只读的。而不传 null 的时候，返回的 MutableRefObject，它的 current 就可以改了。因为 ref 既可以保存 dom 引用，又可以保存其他数据，而保存 dom 引用又要加上 readonly，所以才用 null 做了个区分。 **传 null 就是 dom 引用，返回 RefObject，不传就是其他数据，返回 MutableRefObject。**所以，这就是一种约定，知道传 null 和不传 null 的区别就行了。 参数类型 propsWithChildren 就是给 Props 加了一个 children 属性。 CSSProperties 有时候组件可以通过 props 传入一些 css 的值，这时候怎么写类型呢？ 用 CSSProperties。 HTMLAttributes 如果你写的组件希望可以当成普通 html 标签一样用，也就是可以传很多 html 的属性作为参数呢？ 那可以继承 HTMLAttributes。 ComponentProps 效果与HTMLAttributes一样。 EventHandler 很多时候，组件需要传入一些事件处理函数，这种参数就要用 xxxEventHandler 的类型，比如 MouseEventHandler、ChangeEventHandler 等，它的类型参数是元素的类型。 总结 ReactNode：JSX 的类型，一般用 ReactNode，但要知道 ReactNode、ReactElement、JSX.Element 的关系。 FunctionComonent：也可以写 FC，第一个类型参数是 props 的类型。 useRef 的类型：传入 null 的时候返回的是 RefObj，current 属性只读，用来存 html 元素；不传 null 返回的是 MutableRefObj，current 属性可以修改，用来存普通对象。 ForwardRefRenderFunction：第一个类型参数是 ref 的类型，第二个类型参数是 props 的类型。forwardRef 和它类型参数一样，也可以写在 forwardRef 上。 useReducer：第一个类型参数是 Reducer&lt;data 类型, action 类型&gt;，第二个类型参数是初始化函数的参数类型。 PropsWithChildren：可以用来写有 children 的 props。 CSSProperties： css 样式对象的类型。 HTMLAttributes：组件可以传入 html 标签的属性，也可以指定具体的 ButtonHTMLAttributes、AnchorHTMLAttributes。 ComponentProps：类型参数传入标签名，效果和 HTMLAttributes 一样。 EventHandler：事件处理器的类型。","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[]},{"title":"9-1高浓度赛博垃圾场","slug":"9-1","date":"2024-09-01T12:49:00.000Z","updated":"2024-10-01T06:44:31.568Z","comments":true,"path":"2024/09/01/9-1/","permalink":"https://0922wx.github.io/2024/09/01/9-1/","excerpt":"","text":"博客这种东西，除开一些技术记录，好像也就只有写写日记的功能了。但是正常人谁写日记啊？ ————看到一些荒废的博客有感而发。 所以放弃才是常事。 .rwmgfktxdevb{zoom:50%;} 说起来这个图片怎么这么大，看来我要找找缩小图片的方法了。。。 原来点一下右键就行了，，","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"括号问题","slug":"8-31","date":"2024-08-31T12:33:50.000Z","updated":"2024-09-01T12:18:29.712Z","comments":true,"path":"2024/08/31/8-31/","permalink":"https://0922wx.github.io/2024/08/31/8-31/","excerpt":"","text":"题目中若涉及括号问题，则很有可能和栈相关。","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"栈与队列","slug":"算法/栈与队列","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"}],"tags":[]},{"title":"8-30痛定思痛与继续打牌","slug":"8-30","date":"2024-08-30T11:52:07.000Z","updated":"2024-10-01T06:44:27.893Z","comments":true,"path":"2024/08/30/8-30/","permalink":"https://0922wx.github.io/2024/08/30/8-30/","excerpt":"","text":"明天真得看二叉树了吧，自从黑神话出前三天开始就一直在摸鱼，摸着摸着就到月底了。 学无止境捏。 唉，秋招。唉，春招。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"遗式时间线","slug":"遗式时间线","date":"2024-08-30T11:43:30.000Z","updated":"2024-10-01T06:45:55.885Z","comments":true,"path":"2024/08/30/遗式时间线/","permalink":"https://0922wx.github.io/2024/08/30/%E9%81%97%E5%BC%8F%E6%97%B6%E9%97%B4%E7%BA%BF/","excerpt":"","text":"接触遗式 第一天：美丽强大的海仙女，回手怪效康，还是高贵的康回卡组，我直呼强大。 第二天：我会平等的解放每一个让我开出冰魔镜的人。 第三天：两卡动，本家就一个冷酷一卡动一卡停，还是得靠雷精起场子。 第四天：小时候看到这集为了召唤海仙女扣了3000血。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"游戏王","slug":"日常/游戏王","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B8%B8%E6%88%8F%E7%8E%8B/"}],"tags":[]},{"title":"领悟链表节点","slug":"一张图明了链表","date":"2024-08-30T11:29:38.000Z","updated":"2024-08-30T11:42:36.875Z","comments":true,"path":"2024/08/30/一张图明了链表/","permalink":"https://0922wx.github.io/2024/08/30/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%98%8E%E4%BA%86%E9%93%BE%E8%A1%A8/","excerpt":"","text":"之前总是没理解为什么这个时候操作val,那个时候操作next。直到看到这幅图。哦，这下看懂了。","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"算法/链表","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"}],"tags":[]},{"title":"8-29切合实际与不切实际的幻想时间","slug":"8-29","date":"2024-08-29T12:04:38.000Z","updated":"2024-10-01T06:44:21.228Z","comments":true,"path":"2024/08/29/8-29/","permalink":"https://0922wx.github.io/2024/08/29/8-29/","excerpt":"","text":"8月29日 希望能在开学前敲好秃秃会客室，然后稍加总结。秋招寄了就春招，再寄就去住桥洞。 六级最好也在这学期过了，目标是500左右。 有活的话，想在上班的同时准备一下考研。 九月还有星际战士玩，好。","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"}],"tags":[]},{"title":"快慢指针","slug":"双指针","date":"2024-08-29T02:06:58.000Z","updated":"2024-08-29T11:46:13.682Z","comments":true,"path":"2024/08/29/双指针/","permalink":"https://0922wx.github.io/2024/08/29/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"链表题目简单分为三类： 链表的处理：合并，删除等 链表的反转以及衍生 链表成环及其衍生 做链表处理类问题需要把握一个中心思想——即处理链表的本质，就是处理链表节点之间的指针关系。 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分两类：左右指针和快慢指针。 左右指针，即两个指针相向或者相背而行；快慢指针，即两个指针同向而行，一块一慢。 对于单链表，大部分技巧都属于快慢指针；对于数组，我们把索引当作数组中的指针。 快慢指针技巧 原地修改 数组中常见的快慢指针技巧，比如原地修改数组 26. 删除有序数组中的重复项 | 力扣 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 高效解决这道题就要用到快慢指针技巧： 让慢指针slow走在后面，快指针fast走在前面探路，找到一个不重复的元素就赋值给slow并让slow前进一步。 这样就保证了nums[0…slow]都是无重复元素，fast遍历完整个数组后，nums[0…slow]即是整个数组去重的结果。 12345678910111213141516var removeDuplicates = function(nums) &#123; if (nums.length == 0) &#123; return 0; &#125; let slow = 0, fast = 0; while (fast &lt; nums.length) &#123; if (nums[fast] != nums[slow]) &#123; slow++; // 维护 nums[0..slow] 无重复 nums[slow] = nums[fast]; &#125; fast++; &#125; // 数组长度为索引 + 1 return slow + 1;&#125;; 力扣第83题「删除排序链表中的重复元素」，链表去重与数组去重相似，唯一的区别是把数组赋值操作变成操作指针而已。 1234567891011121314var deleteDuplicates = function(head) &#123; if(head === null) return null let fast =head,slow = head while(fast !==null)&#123;​ if(fast.val !== slow.val)&#123;​ slow.next = fast​ slow = slow.next​ &#125;​ fast++ &#125; // 断开与后面重复元素的连接 slow.next = null; return head;&#125;; (说起来，去重数组用Set()在力扣居然也能通过。) 滑动窗口 暂时不会，会了再说吧","categories":[{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"算法/双指针","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[]},{"title":"浅拷贝与深拷贝","slug":"Deep-and-Shallow-Copy","date":"2024-08-27T16:00:00.000Z","updated":"2024-09-02T12:11:48.087Z","comments":true,"path":"2024/08/28/Deep-and-Shallow-Copy/","permalink":"https://0922wx.github.io/2024/08/28/Deep-and-Shallow-Copy/","excerpt":"","text":"记录于7月3号，语雀 首先明确JS的数据类型能分成基本数字类型和引用类型 1234let a =10;let b =a;a =100;console.log(b); //结果为10 基本数字类型之间拷贝传递的就是值。在栈中，声明一个变量a，再将a赋值给b，此时栈中a=10，b=10，两者相互独立，所以a值的修改并不影响b。 1234let a =[1,2,3,4];let b =a;a[0] =100;console.log(b); //结果为[100,2,3,4] 我们修改了数组a，却也影响了数组b，引用类型的值(栈中)存放的并非数值本身，而是内存地址，仅拷贝地址，就是浅拷贝。 一些深拷贝的方法 1234567let a =[1,2,3,4];let b =[...a];a[0] =100;console.log(b);console.log(a);//b:[1,2,3,4]//a:[100,2,3,4] 从内存里面开辟一块新的空间存放数组，利用展开运算符把a的每一项存入数组中，虽然有效，然有其局限，遇上多维数组就不管用了。 为什么不管用？ 二维数组内的数组仍然是引用类型，对应另一个地址存储了这个数组。虽然我们经过了拷贝，在堆里开辟一个新空间存储给b，但是001中的二维数组存的就是一个地址，所以新开辟的空间拿到的也是一个地址。 所以我们要想办法实现多层拷贝，各自开辟独立空间，互不干扰。 如果是基本类型数据，他们的拷贝就是深拷贝；对于引用类型数据，不论数据是一层还是多层，只要把内部的引用类型数据全部独立开辟内存空间，数据完全互不干扰，就是深拷贝，只要有共用数据就是浅拷贝。 多层拷贝 常用方法:Json格式转化 123456let a =[1,2,3,4,[5,6,&#123;name:&#x27;wx&#x27;&#125;]];let b =JSON.parse(stringify(a));console.log(b);console.log(typeof b);//[1,2,3,4[5,6,&#123;name:&#x27;wx&#x27;&#125;]]//object 为数不多的缺点就是无法转化拷贝函数类型(这真的是我要考虑的东西吗)。 所以说，接下来就是实现函数的拷贝。 如果没有嵌套数据，使用展开运算符即可解决，能解决的原因是这里修改一个函数等于重写一个函数，重写就会在内存里开辟一个新空间。所以，如果我们的数据里没有嵌套数组和对象，又有函数，是可以直接用展开运算符来拷贝的(好用，爱用，虽然我还没有实际用到过)。 12345678910let a =&#123; name:&#x27;wx&#x27;, age:18, fn()&#123; console.log(this.name); &#125; &#125;let b =&#123;...a&#125;;console.log(&quot;a为:&quot;,a); //&#123;name:&#x27;wx&#x27;,age:18,fn:f&#125;console.log(&quot;b为:&quot;,b); //&#123;name:&#x27;wx&#x27;,age:18,fn:f&#125; 手写一个递归实现相对完美的深拷贝 12345678910111213function deepClone(oldData)&#123; //进入循坏条件为数组或者对象,具体是什么得继续判断 if(typeof oldData === &#x27;object&#x27; &amp;&amp; oldData !== null)&#123; //如果是数组就新建一个新数组，否则就新建一个对象 let res =Array.isArray(oldData)? [] : &#123;&#125;; for(let k in oldData)&#123; res[k] = deepClone(oldData[k]); &#125; return res; &#125;else&#123; return oldData; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"}],"tags":[]},{"title":"","slug":"初衷","date":"2024-08-27T16:00:00.000Z","updated":"2024-10-13T06:48:43.248Z","comments":true,"path":"2024/08/28/初衷/","permalink":"https://0922wx.github.io/2024/08/28/%E5%88%9D%E8%A1%B7/","excerpt":"","text":"🕕🤖👾⛄🕦","categories":[{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Typescript","slug":"前端/Typescript","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Typescript/"},{"name":"日常","slug":"日常","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"流水账","slug":"日常/流水账","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/"},{"name":"2024年","slug":"日常/流水账/2024年","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B5%81%E6%B0%B4%E8%B4%A6/2024%E5%B9%B4/"},{"name":"面试","slug":"前端/面试","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"},{"name":"HackerRank三个月挑战","slug":"HackerRank三个月挑战","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/"},{"name":"第二周","slug":"HackerRank三个月挑战/第二周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%BA%8C%E5%91%A8/"},{"name":"后端","slug":"后端","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"nest","slug":"后端/nest","permalink":"https://0922wx.github.io/categories/%E5%90%8E%E7%AB%AF/nest/"},{"name":"第三周","slug":"HackerRank三个月挑战/第三周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%89%E5%91%A8/"},{"name":"vscode","slug":"前端/vscode","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/vscode/"},{"name":"面试题","slug":"前端/面试题","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"TS类型体操","slug":"TS类型体操","permalink":"https://0922wx.github.io/categories/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"},{"name":"简单题","slug":"TS类型体操/简单题","permalink":"https://0922wx.github.io/categories/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/%E7%AE%80%E5%8D%95%E9%A2%98/"},{"name":"Js有的没的","slug":"前端/Js有的没的","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/Js%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"},{"name":"ThreeJs","slug":"前端/ThreeJs","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/ThreeJs/"},{"name":"事前准备","slug":"前端/ThreeJs/事前准备","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/ThreeJs/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"},{"name":"css","slug":"前端/css","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/css/"},{"name":"第一周","slug":"HackerRank三个月挑战/第一周","permalink":"https://0922wx.github.io/categories/HackerRank%E4%B8%89%E4%B8%AA%E6%9C%88%E6%8C%91%E6%88%98/%E7%AC%AC%E4%B8%80%E5%91%A8/"},{"name":"算法","slug":"算法","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"算法/链表","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"name":"项目","slug":"项目","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"组件库","slug":"项目/组件库","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"事前准备","slug":"项目/组件库/事前准备","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E7%BB%84%E4%BB%B6%E5%BA%93/%E4%BA%8B%E5%89%8D%E5%87%86%E5%A4%87/"},{"name":"表情包制作","slug":"项目/表情包制作","permalink":"https://0922wx.github.io/categories/%E9%A1%B9%E7%9B%AE/%E8%A1%A8%E6%83%85%E5%8C%85%E5%88%B6%E4%BD%9C/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"React","slug":"前端/React","permalink":"https://0922wx.github.io/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"二叉树","slug":"算法/二叉树","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"栈与队列","slug":"算法/栈与队列","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"name":"游戏王","slug":"日常/游戏王","permalink":"https://0922wx.github.io/categories/%E6%97%A5%E5%B8%B8/%E6%B8%B8%E6%88%8F%E7%8E%8B/"},{"name":"双指针","slug":"算法/双指针","permalink":"https://0922wx.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[]}